# Binary Injection Tasks for pf-runner
# This file contains tasks for injecting compiled code into binaries and shared libraries

# ============================================================================
# Installation Tasks
# ============================================================================
# Note: install-injection-tools task is defined at the end of this file for better organization

# ============================================================================
# Payload Generation Tasks
# ============================================================================

task create-injection-payload-rust
  describe Create injectable shared library from Rust code (source=path/to/rust/project, target=x86_64-unknown-linux-gnu)
   bash
  shell test -n "${source}" || (echo "Error: source parameter required" && exit 1)
  shell cd ${source}
  shell mkdir -p ../injection/payloads/rust
  shell cargo build --target ${target:-x86_64-unknown-linux-gnu} --release --lib
  shell cp target/${target:-x86_64-unknown-linux-gnu}/release/*.so ../injection/payloads/rust/ 2>/dev/null || echo "No .so files generated - check Cargo.toml crate-type"
  shell echo "Rust payload created in ../injection/payloads/rust/"
end

task create-injection-payload-c
  describe Create injectable shared library from C code (source=file.c, output=libname.so)
   bash
  shell test -n "${source}" || (echo "Error: source parameter required" && exit 1)
  shell mkdir -p injection/payloads/c
  shell gcc -shared -fPIC -O2 ${source} -o injection/payloads/c/${output:-payload.so}
  shell echo "C payload created: injection/payloads/c/${output:-payload.so}"
  shell file injection/payloads/c/${output:-payload.so}
end

task create-injection-payload-fortran
  describe Create injectable shared library from Fortran code (source=file.f90, output=libname.so)
   bash
  shell test -n "${source}" || (echo "Error: source parameter required" && exit 1)
  shell mkdir -p injection/payloads/fortran
  shell gfortran -shared -fPIC -O2 ${source} -o injection/payloads/fortran/${output:-payload.so}
  shell echo "Fortran payload created: injection/payloads/fortran/${output:-payload.so}"
  shell file injection/payloads/fortran/${output:-payload.so}
end

task create-injection-payload-llvm
  describe Create injectable shared library from LLVM IR (source=file.ll, output=libname.so)
   bash
  shell test -n "${source}" || (echo "Error: source parameter required" && exit 1)
  shell mkdir -p injection/payloads/llvm
  shell clang -shared -fPIC -O2 ${source} -o injection/payloads/llvm/${output:-payload.so}
  shell echo "LLVM IR payload created: injection/payloads/llvm/${output:-payload.so}"
  shell file injection/payloads/llvm/${output:-payload.so}
end

task create-injection-payload-wasm-native
  describe Convert WASM to native shared library using wasm2c (source=file.wasm, output=libname.so)
   bash
  shell test -n "${source}" || (echo "Error: source parameter required" && exit 1)
  shell mkdir -p injection/payloads/wasm-native
  shell wasm2c ${source} -o injection/payloads/wasm-native/$(basename ${source%.wasm}).c
  shell gcc -shared -fPIC -O2 injection/payloads/wasm-native/$(basename ${source%.wasm}).c -o injection/payloads/wasm-native/${output:-$(basename ${source%.wasm}).so}
  shell echo "WASM-to-native payload created: injection/payloads/wasm-native/${output:-$(basename ${source%.wasm}).so}"
  shell file injection/payloads/wasm-native/${output:-$(basename ${source%.wasm}).so}
end

# ============================================================================
# Binary Analysis for Injection
# ============================================================================

task analyze-injection-target
  describe Analyze binary for injection opportunities (binary=/path/to/binary)
   bash
  shell test -n "${binary}" || (echo "Error: binary parameter required" && exit 1)
  shell echo "=== Binary Injection Analysis ==="
  shell echo "Target: ${binary}"
  shell file ${binary}
  shell echo ""
  shell echo "Dependencies:"
  shell ldd ${binary} 2>/dev/null || otool -L ${binary} 2>/dev/null || echo "Dependency analysis not available"
  shell echo ""
  shell echo "Symbols (first 20):"
  shell nm -D ${binary} 2>/dev/null | head -20 || echo "Symbol analysis not available"
  shell echo ""
  shell echo "Sections:"
  shell objdump -h ${binary} 2>/dev/null | grep -E "(\.text|\.data|\.bss|\.plt|\.got)" || echo "Section analysis not available"
  shell echo ""
  shell echo "Security features:"
  shell checksec --file=${binary} 2>/dev/null || echo "checksec not available - install pax-utils or checksec.sh"
end

task find-injection-points
  describe Find potential injection points in binary (binary=/path/to/binary)
   bash
  shell test -n "${binary}" || (echo "Error: binary parameter required" && exit 1)
  shell echo "=== Injection Point Analysis ==="
  shell echo "1. Constructor/Destructor sections:"
  shell objdump -h ${binary} 2>/dev/null | grep -E "(\.init|\.fini|\.ctors|\.dtors)" || echo "No constructor/destructor sections found"
  shell echo ""
  shell echo "2. PLT entries (function calls):"
  shell objdump -d ${binary} 2>/dev/null | grep -E "plt>" | head -10 || echo "No PLT entries found"
  shell echo ""
  shell echo "3. GOT entries (global offset table):"
  shell objdump -R ${binary} 2>/dev/null | head -10 || echo "No GOT entries found"
  shell echo ""
  shell echo "4. Dynamic symbols:"
  shell nm -D ${binary} 2>/dev/null | grep -E "(main|init|fini)" || echo "No relevant dynamic symbols found"
end

# ============================================================================
# Static Binary Injection (Binary Patching)
# ============================================================================

task inject-static-library
  describe Inject shared library into binary using binary patching (binary=/path/to/binary, payload=/path/to/payload.so)
   bash
  shell test -n "${binary}" || (echo "Error: binary parameter required" && exit 1)
  shell test -n "${payload}" || (echo "Error: payload parameter required" && exit 1)
  shell test -f "${payload}" || (echo "Error: payload file not found: ${payload}" && exit 1)
  shell mkdir -p injection/patched
  shell cp ${binary} injection/patched/$(basename ${binary})_patched
  shell echo "Patching binary to load ${payload}..."
  shell python3 tools/injection/patch-binary.py injection/patched/$(basename ${binary})_patched ${payload}
  shell echo "Patched binary created: injection/patched/$(basename ${binary})_patched"
  shell file injection/patched/$(basename ${binary})_patched
end

task inject-constructor
  describe Inject code via constructor function (binary=/path/to/binary, payload=/path/to/payload.so)
   bash
  shell test -n "${binary}" || (echo "Error: binary parameter required" && exit 1)
  shell test -n "${payload}" || (echo "Error: payload parameter required" && exit 1)
  shell mkdir -p injection/patched
  shell cp ${binary} injection/patched/$(basename ${binary})_with_constructor
  shell echo "Adding constructor injection to binary..."
  shell python3 tools/injection/add-constructor.py injection/patched/$(basename ${binary})_with_constructor ${payload}
  shell echo "Constructor-injected binary: injection/patched/$(basename ${binary})_with_constructor"
end

# ============================================================================
# Dynamic Injection (Runtime)
# ============================================================================

task inject-runtime-library
  describe Inject shared library into running process (pid=process_id, payload=/path/to/payload.so)
   bash
  shell test -n "${pid}" || (echo "Error: pid parameter required" && exit 1)
  shell test -n "${payload}" || (echo "Error: payload parameter required" && exit 1)
  shell test -f "${payload}" || (echo "Error: payload file not found: ${payload}" && exit 1)
  shell echo "Injecting ${payload} into process ${pid}..."
  shell python3 tools/injection/runtime-inject.py ${pid} ${payload}
  shell echo "Runtime injection completed"
end

task inject-preload
  describe Use LD_PRELOAD to inject library (binary=/path/to/binary, payload=/path/to/payload.so)
   bash
  shell test -n "${binary}" || (echo "Error: binary parameter required" && exit 1)
  shell test -n "${payload}" || (echo "Error: payload parameter required" && exit 1)
  shell test -f "${payload}" || (echo "Error: payload file not found: ${payload}" && exit 1)
  shell echo "Running ${binary} with LD_PRELOAD injection..."
  shell env LD_PRELOAD=${payload} ${binary} ${args}
end

# ============================================================================
# Cross-Platform Injection
# ============================================================================

task inject-macos-dylib
  describe Inject dylib into macOS binary (binary=/path/to/binary, payload=/path/to/payload.dylib)
   bash
  shell test -n "${binary}" || (echo "Error: binary parameter required" && exit 1)
  shell test -n "${payload}" || (echo "Error: payload parameter required" && exit 1)
  shell mkdir -p injection/patched
  shell cp ${binary} injection/patched/$(basename ${binary})_injected
  shell echo "Injecting dylib into macOS binary..."
  shell install_name_tool -add_rpath @executable_path injection/patched/$(basename ${binary})_injected
  shell install_name_tool -change /usr/lib/libSystem.B.dylib ${payload} injection/patched/$(basename ${binary})_injected 2>/dev/null || echo "Direct dylib injection may require additional steps"
  shell echo "macOS injection completed: injection/patched/$(basename ${binary})_injected"
end

# ============================================================================
# End-to-End Injection Workflows
# ============================================================================

task inject-rust-into-binary
  describe Complete workflow: Rust source → shared library → binary injection (rust_source=path, target_binary=path)
   bash
  shell test -n "${rust_source}" || (echo "Error: rust_source parameter required" && exit 1)
  shell test -n "${target_binary}" || (echo "Error: target_binary parameter required" && exit 1)
  shell echo "=== Complete Rust Injection Workflow ==="
  shell echo "1. Creating Rust payload..."
  shell pf create-injection-payload-rust source=${rust_source}
  shell echo "2. Analyzing target binary..."
  shell pf analyze-injection-target binary=${target_binary}
  shell echo "3. Performing injection..."
  shell pf inject-static-library binary=${target_binary} payload=injection/payloads/rust/*.so
  shell echo "=== Injection workflow complete ==="
end

task inject-c-into-binary
  describe Complete workflow: C source → shared library → binary injection (c_source=file.c, target_binary=path)
   bash
  shell test -n "${c_source}" || (echo "Error: c_source parameter required" && exit 1)
  shell test -n "${target_binary}" || (echo "Error: target_binary parameter required" && exit 1)
  shell echo "=== Complete C Injection Workflow ==="
  shell echo "1. Creating C payload..."
  shell pf create-injection-payload-c source=${c_source} output=injected_payload.so
  shell echo "2. Analyzing target binary..."
  shell pf analyze-injection-target binary=${target_binary}
  shell echo "3. Performing injection..."
  shell pf inject-static-library binary=${target_binary} payload=injection/payloads/c/injected_payload.so
  shell echo "=== Injection workflow complete ==="
end

task inject-wasm-into-binary
  describe Complete workflow: WASM → native shared library → binary injection (wasm_source=file.wasm, target_binary=path)
   bash
  shell test -n "${wasm_source}" || (echo "Error: wasm_source parameter required" && exit 1)
  shell test -n "${target_binary}" || (echo "Error: target_binary parameter required" && exit 1)
  shell echo "=== Complete WASM Injection Workflow ==="
  shell echo "1. Converting WASM to native payload..."
  shell pf create-injection-payload-wasm-native source=${wasm_source} output=wasm_payload.so
  shell echo "2. Analyzing target binary..."
  shell pf analyze-injection-target binary=${target_binary}
  shell echo "3. Performing injection..."
  shell pf inject-static-library binary=${target_binary} payload=injection/payloads/wasm-native/wasm_payload.so
  shell echo "=== WASM injection workflow complete ==="
end

# ============================================================================
# Example Building Tasks
# ============================================================================

task build-injection-examples
  describe Build all example injection payloads and target applications
   bash
  shell cd demos/binary-injection/examples
  shell echo "Building target application..."
  shell gcc -o target-app target-app.c
  shell echo "Building C injection payload..."
  shell gcc -shared -fPIC simple-payload.c -ldl -o simple-payload.so
  shell echo "Building Fortran injection payload..."
  shell gfortran -shared -fPIC fortran-payload.f90 fortran-wrapper.c -o fortran-payload.so
  shell echo "Building Rust injection payload..."
  shell cd rust-payload && cargo build --release --target x86_64-unknown-linux-gnu
  shell cd ..
  shell cp rust-payload/target/x86_64-unknown-linux-gnu/release/librust_payload.so rust-payload.so 2>/dev/null || echo "Rust payload build may have failed"
  shell echo "All injection examples built successfully!"
  shell ls -lh *.so target-app 2>/dev/null || true
end

task clean-injection-examples
  describe Clean built injection examples
   bash
  shell cd demos/binary-injection/examples
  shell rm -f target-app *.so
  shell cd rust-payload && cargo clean 2>/dev/null || true
  shell echo "Cleaned injection examples"
end

# ============================================================================
# Testing and Validation
# ============================================================================

task test-injection-workflow
  describe Test complete injection workflow with example binaries
   bash
  shell echo "=== Testing Binary Injection Workflow ==="
  shell echo "1. Building example applications and payloads..."
  shell pf build-injection-examples
  shell echo "2. Testing LD_PRELOAD injection with C payload..."
  shell cd demos/binary-injection/examples
  shell echo "Running target app with C injection:"
  shell env LD_PRELOAD=./simple-payload.so ./target-app
  shell echo "3. Testing LD_PRELOAD injection with Rust payload..."
  shell echo "Running target app with Rust injection:"
  shell env LD_PRELOAD=./rust-payload.so ./target-app 2>/dev/null || echo "Rust payload may not be available"
  shell echo "4. Testing LD_PRELOAD injection with Fortran payload..."
  shell echo "Running target app with Fortran injection:"
  shell env LD_PRELOAD=./fortran-payload.so ./target-app 2>/dev/null || echo "Fortran payload may not be available"
  shell echo "=== Injection workflow test complete ==="
  shell echo "All injection methods tested successfully!"
end

task clean-injection-artifacts
  describe Clean all injection-related build artifacts
   bash
  shell rm -rf injection/
  shell echo "Cleaned injection artifacts"
end

# ============================================================================
# Documentation and Help
# Binary Injection and Shared Library Compilation Tasks
# This file contains tasks for compiling code to shared libraries and injecting into binaries

# ============================================================================
# Shared Library Compilation Tasks
# ============================================================================

task compile-c-shared-lib
  describe Compile C code to shared library (.so on Linux, .dylib on macOS) - source=/path/to/file.c output=/path/to/lib.so
  shell test -n "$source" || (echo "Error: source parameter required" && exit 1)
  shell test -z "$output" && output="lib.so"; mkdir -p "$(dirname "$output")"; clang -shared -fPIC -O2 "$source" -o "$output"
  shell echo "Compiled shared library: $output"
  shell file "$output"
end

task compile-rust-shared-lib
  describe Compile Rust code to shared library (.so/.dylib) - crate=/path/to/crate output=/path/to/lib.so
  shell test -n "${crate}" || (echo "Error: crate parameter required" && exit 1)
  shell cd ${crate} && cargo build --release --lib
  shell echo "Compiled shared library in ${crate}/target/release/"
  shell ls -lh ${crate}/target/release/*.so ${crate}/target/release/*.dylib 2>/dev/null || echo "Built library"
end

task compile-fortran-shared-lib
  describe Compile Fortran code to shared library (.so/.dylib) - source=/path/to/file.f90 output=/path/to/lib.so
  shell test -n "${source}" || (echo "Error: source parameter required" && exit 1)
  shell mkdir -p $(dirname ${output:-lib.so})
  shell if [ "$(uname)" = "Darwin" ]; then gfortran -shared -fPIC -O2 ${source} -o ${output:-lib.dylib}; else gfortran -shared -fPIC -O2 ${source} -o ${output:-lib.so}; fi
  shell echo "Compiled shared library: ${output:-lib.so}"
  shell file ${output:-lib.so}
end

task compile-cpp-shared-lib
  describe Compile C++ code to shared library (.so/.dylib) - source=/path/to/file.cpp output=/path/to/lib.so
  shell test -n "${source}" || (echo "Error: source parameter required" && exit 1)
  shell mkdir -p $(dirname ${output:-lib.so})
  shell if [ "$(uname)" = "Darwin" ]; then clang++ -shared -fPIC -O2 -std=c++17 ${source} -o ${output:-lib.dylib}; else clang++ -shared -fPIC -O2 -std=c++17 ${source} -o ${output:-lib.so}; fi
  shell echo "Compiled shared library: ${output:-lib.so}"
  shell file ${output:-lib.so}
end

# ============================================================================
# WASM/ASM.js to Native Conversion Tasks
# ============================================================================

task wasm-to-native
  describe Convert WebAssembly to native shared library - input=/path/to/file.wasm output=/path/to/lib.so
  shell test -n "${input}" || (echo "Error: input parameter required" && exit 1)
  shell mkdir -p $(dirname ${output:-lib.so})
  shell echo "Converting WASM to native requires wasm2c from WABT + compilation"
  shell wasm2c ${input} -o ${input%.wasm}.c 2>/dev/null || (echo "Error: wasm2c not available. Install WABT: sudo apt-get install wabt" && exit 1)
  shell if [ "$(uname)" = "Darwin" ]; then clang -shared -fPIC -O2 ${input%.wasm}.c -o ${output:-lib.dylib}; else clang -shared -fPIC -O2 ${input%.wasm}.c -o ${output:-lib.so}; fi
  shell echo "Compiled native library: ${output:-lib.so}"
  shell rm -f ${input%.wasm}.c
end

task asm-to-native
  describe Convert asm.js to native shared library - input=/path/to/file_asm.js output=/path/to/lib.so
  shell test -n "${input}" || (echo "Error: input parameter required" && exit 1)
  shell echo "Note: asm.js is JavaScript, direct conversion to native requires complex transpilation"
  shell echo "Consider using the original C/C++ source with compile-c-shared-lib or compile-cpp-shared-lib"
end

# ============================================================================
# Binary Injection and Patching Tasks
# ============================================================================

task inject-shared-lib
  describe Inject/preload a shared library into a binary execution - binary=/path/to/binary lib=/path/to/lib.so args="binary args"
  shell test -n "${binary}" || (echo "Error: binary parameter required" && exit 1)
  shell test -n "${lib}" || (echo "Error: lib parameter required" && exit 1)
  shell test -f "${lib}" || (echo "Error: Library ${lib} not found" && exit 1)
  shell echo "Running ${binary} with preloaded library ${lib}"
  shell if [ "$(uname)" = "Darwin" ]; then DYLD_INSERT_LIBRARIES=${lib} DYLD_FORCE_FLAT_NAMESPACE=1 ${binary} ${args}; else LD_PRELOAD=${lib} ${binary} ${args}; fi
end

task patch-binary-deps
  describe Patch binary to use custom shared library - binary=/path/to/binary old_lib=libold.so new_lib=/path/to/libnew.so
  shell test -n "${binary}" || (echo "Error: binary parameter required" && exit 1)
  shell test -n "${old_lib}" || (echo "Error: old_lib parameter required" && exit 1)
  shell test -n "${new_lib}" || (echo "Error: new_lib parameter required" && exit 1)
  shell echo "Patching ${binary} to replace ${old_lib} with ${new_lib}"
  shell if [ "$(uname)" = "Darwin" ]; then install_name_tool -change ${old_lib} ${new_lib} ${binary}; else patchelf --replace-needed ${old_lib} ${new_lib} ${binary} 2>/dev/null || (echo "Error: patchelf not installed. Install with: sudo apt-get install patchelf" && exit 1); fi
  shell echo "Binary patched successfully"
  shell if [ "$(uname)" = "Darwin" ]; then otool -L ${binary}; else ldd ${binary}; fi
end

task inspect-binary-deps
  describe Inspect shared library dependencies of a binary - binary=/path/to/binary
  shell test -n "${binary}" || (echo "Error: binary parameter required" && exit 1)
  shell echo "Dependencies for ${binary}:"
  shell if [ "$(uname)" = "Darwin" ]; then otool -L ${binary}; else ldd ${binary}; fi
end

task create-hook-lib
  describe Create a hook library template for function interception - output=/path/to/hook.c
  shell test -z "$output" && output=hook.c; bash tools/injection/create-hook-lib.sh "$output"
end

# ============================================================================
# WebAssembly Injection Tasks
# ============================================================================

task inject-wasm-component
  describe Inject WASM component into an existing WASM module - host=/path/to/host.wasm component=/path/to/component.wasm output=/path/to/combined.wasm
  shell test -n "${host}" || (echo "Error: host parameter required" && exit 1)
  shell test -n "${component}" || (echo "Error: component parameter required" && exit 1)
  shell mkdir -p $(dirname ${output:-combined.wasm})
  shell echo "Combining WASM modules..."
  shell wasm-merge ${host} main ${component} injected -o ${output:-combined.wasm} 2>/dev/null || (echo "Error: wasm-merge not available. This requires Binaryen: sudo apt-get install binaryen" && exit 1)
  shell echo "Combined WASM module: ${output:-combined.wasm}"
  shell wasm-objdump -x ${output:-combined.wasm} | head -50
end

task create-wasm-hook
  describe Create WebAssembly hook/wrapper module - output=/path/to/hook.wat
  shell test -z "$output" && output=hook.wat; bash tools/injection/create-wasm-hook.sh "$output"
end

# ============================================================================
# Assembly-Level Injection Tasks
# ============================================================================

task inject-asm-patch
  describe Inject assembly code patch into binary - binary=/path/to/binary patch=/path/to/patch.asm offset=0x1000
  shell test -n "${binary}" || (echo "Error: binary parameter required" && exit 1)
  shell test -n "${patch}" || (echo "Error: patch parameter required" && exit 1)
  shell test -n "${offset}" || (echo "Error: offset parameter required" && exit 1)
  shell echo "Assembling patch..."
  shell nasm -f bin ${patch} -o /tmp/patch.bin 2>/dev/null || (echo "Error: nasm not installed. Install with: sudo apt-get install nasm" && exit 1)
  shell echo "Creating backup..."
  shell cp ${binary} ${binary}.backup
  shell echo "Patching binary at offset ${offset}..."
  shell dd if=/tmp/patch.bin of=${binary} bs=1 seek=$((${offset})) conv=notrunc
  shell echo "Patch applied. Backup saved as ${binary}.backup"
  shell rm -f /tmp/patch.bin
end

task disassemble-for-injection
  describe Disassemble binary section for injection analysis - binary=/path/to/binary section=.text
  shell test -n "${binary}" || (echo "Error: binary parameter required" && exit 1)
  shell echo "Disassembling ${binary} section ${section:-.text}..."
  shell objdump -d -j ${section:-.text} ${binary} | head -100
  shell echo ""
  shell echo "Use this output to find injection points"
end

# ============================================================================
# Complete Injection Workflow Tasks
# ============================================================================

task demo-injection-workflow
  describe Demonstrate complete injection workflow with C code
  shell echo "=== Binary Injection Workflow Demo ==="
  shell mkdir -p demos/injection-demo
  shell echo "1. Creating hook library source..."
  shell pf create-hook-lib output=demos/injection-demo/hook.c
  shell echo "2. Compiling hook library..."
  shell pf compile-c-shared-lib source=demos/injection-demo/hook.c output=demos/injection-demo/hook.so
  shell echo "3. Creating test program..."
  shell echo '#include <stdio.h>' > demos/injection-demo/test.c
  shell echo '#include <stdlib.h>' >> demos/injection-demo/test.c
  shell echo 'int main() {' >> demos/injection-demo/test.c
  shell echo '    void* p = malloc(100);' >> demos/injection-demo/test.c
  shell echo '    printf("Allocated: %p\\n", p);' >> demos/injection-demo/test.c
  shell echo '    free(p);' >> demos/injection-demo/test.c
  shell echo '    return 0;' >> demos/injection-demo/test.c
  shell echo '}' >> demos/injection-demo/test.c
  shell gcc demos/injection-demo/test.c -o demos/injection-demo/test
  shell echo "4. Running with hook library..."
  shell pf inject-shared-lib binary=demos/injection-demo/test lib=demos/injection-demo/hook.so
  shell echo ""
  shell echo "=== Demo Complete ==="
end

task demo-wasm-injection
  describe Demonstrate WASM component injection workflow
  shell echo "=== WASM Injection Workflow Demo ==="
  shell mkdir -p demos/wasm-injection-demo
  shell echo "1. Creating base WASM module..."
  shell cat > demos/wasm-injection-demo/base.wat << 'WAT_EOF'
(module
  (func $original (param $x i32) (result i32)
    local.get $x
    i32.const 10
    i32.mul)
  (export "calculate" (func $original))
)
WAT_EOF
  shell wat2wasm demos/wasm-injection-demo/base.wat -o demos/wasm-injection-demo/base.wasm 2>/dev/null || echo "WABT not installed"
  shell echo "2. Creating hook component..."
  shell pf create-wasm-hook output=demos/wasm-injection-demo/hook.wat
  shell echo "=== Demo files created in demos/wasm-injection-demo/ ==="
  shell ls -lh demos/wasm-injection-demo/
end

# ============================================================================
# Installation Tasks
# ============================================================================

task install-injection-tools
  describe Install tools needed for binary injection (patchelf, nasm, binaryen)
  shell echo "Installing binary injection tools..."
  shell OS="$(uname)"
  shell if [ "$OS" = "Linux" ]; then if command -v apt-get >/dev/null 2>&1; then sudo apt-get update && sudo apt-get install -y patchelf nasm binaryen wabt; elif command -v dnf >/dev/null 2>&1; then sudo dnf install -y patchelf nasm binaryen wabt; elif command -v pacman >/dev/null 2>&1; then sudo pacman -S --noconfirm patchelf nasm binaryen wabt; else echo "Unsupported Linux distribution. Please install manually: patchelf, nasm, binaryen, wabt"; fi; elif [ "$OS" = "Darwin" ]; then if command -v brew >/dev/null 2>&1; then brew install patchelf nasm binaryen wabt; else echo "Homebrew not found. Install from https://brew.sh then run: brew install patchelf nasm binaryen wabt"; fi; else echo "Unsupported OS. Please install manually: patchelf, nasm, binaryen, wabt"; fi
  shell echo "Verifying installations..."
  shell patchelf --version 2>/dev/null || echo "  patchelf: NOT installed"
  shell nasm -version 2>/dev/null || echo "  nasm: NOT installed"
  shell wasm-merge --version 2>/dev/null || echo "  binaryen: NOT installed"
  shell wasm2c --version 2>/dev/null || echo "  wabt: NOT installed"
end

# ============================================================================
# Help and Documentation Tasks
# ============================================================================

task injection-help
  describe Show help for binary injection tasks
  shell echo "=== Binary Injection and Shared Library Compilation ==="
  shell echo ""
  shell echo "SHARED LIBRARY COMPILATION:"
  shell echo "  pf compile-c-shared-lib source=code.c output=lib.so"
  shell echo "  pf compile-rust-shared-lib crate=./my-crate"
  shell echo "  pf compile-fortran-shared-lib source=code.f90 output=lib.so"
  shell echo "  pf compile-cpp-shared-lib source=code.cpp output=lib.so"
  shell echo ""
  shell echo "WASM/ASM CONVERSION:"
  shell echo "  pf wasm-to-native input=module.wasm output=lib.so"
  shell echo ""
  shell echo "BINARY INJECTION:"
  shell echo "  pf inject-shared-lib binary=./program lib=hook.so"
  shell echo "  pf patch-binary-deps binary=./program old_lib=libold.so new_lib=./libnew.so"
  shell echo "  pf inspect-binary-deps binary=./program"
  shell echo ""
  shell echo "HOOK CREATION:"
  shell echo "  pf create-hook-lib output=hook.c"
  shell echo "  pf create-wasm-hook output=hook.wat"
  shell echo ""
  shell echo "WASM INJECTION:"
  shell echo "  pf inject-wasm-component host=base.wasm component=plugin.wasm output=combined.wasm"
  shell echo ""
  shell echo "ASSEMBLY PATCHING:"
  shell echo "  pf disassemble-for-injection binary=./program"
  shell echo "  pf inject-asm-patch binary=./program patch=code.asm offset=0x1000"
  shell echo ""
  shell echo "DEMONSTRATIONS:"
  shell echo "  pf demo-injection-workflow"
  shell echo "  pf demo-wasm-injection"
  shell echo ""
  shell echo "INSTALLATION:"
  shell echo "  pf install-injection-tools"
end
