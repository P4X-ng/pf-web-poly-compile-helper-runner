/**
 * Heap Vulnerability Demonstration
 * 
 * This example demonstrates common heap vulnerabilities:
 * - Heap overflow
 * - Use-after-free
 * - Double-free
 * - Heap metadata corruption
 * 
 * Shows WHY heap spraying is so common - it makes exploitation easier
 * 
 * FOR EDUCATIONAL PURPOSES ONLY
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../src/heap_spray.h"

void demonstrate_heap_overflow(void) {
    printf("\n===== HEAP OVERFLOW VULNERABILITY =====\n\n");
    
    printf("Heap overflow occurs when data is written beyond the boundaries\n");
    printf("of an allocated chunk. This can corrupt adjacent chunks or\n");
    printf("heap metadata, leading to arbitrary code execution.\n\n");
    
    printf("[*] Creating vulnerable scenario...\n\n");
    
    // Allocate two adjacent chunks
    char *chunk1 = malloc(32);
    char *chunk2 = malloc(32);
    
    printf("Chunk 1 at: 0x%lx\n", (unsigned long)chunk1);
    printf("Chunk 2 at: 0x%lx\n", (unsigned long)chunk2);
    printf("Distance: %ld bytes\n\n", (long)(chunk2 - chunk1));
    
    // Fill chunks with identifiable patterns
    memset(chunk1, 'A', 32);
    memset(chunk2, 'B', 32);
    
    printf("Before overflow:\n");
    printf("Chunk 1: ");
    for (int i = 0; i < 16; i++) printf("%c", chunk1[i]);
    printf("...\n");
    printf("Chunk 2: ");
    for (int i = 0; i < 16; i++) printf("%c", chunk2[i]);
    printf("...\n\n");
    
    printf("[!] Triggering overflow by writing 48 bytes into 32-byte buffer...\n\n");
    
    // This would overflow in a real vulnerability (demonstrated safely)
    char overflow_data[48];
    memset(overflow_data, 'X', 48);
    
    printf("In a real exploit, this would overflow into chunk2 and potentially\n");
    printf("corrupt heap metadata, allowing:\n");
    printf("- Overwriting function pointers\n");
    printf("- Corrupting size fields\n");
    printf("- Arbitrary write primitives\n\n");
    
    printf("WHY HEAP SPRAY HELPS:\n");
    printf("By spraying the heap with controlled data, an attacker can:\n");
    printf("1. Predict where data will land after overflow\n");
    printf("2. Ensure overflow hits attacker-controlled memory\n");
    printf("3. Place shellcode/gadgets at predictable addresses\n\n");
    
    // Clean up
    free(chunk1);
    free(chunk2);
}

void demonstrate_use_after_free(void) {
    printf("\n===== USE-AFTER-FREE VULNERABILITY =====\n\n");
    
    printf("Use-after-free occurs when a program continues to use memory\n");
    printf("after it has been freed. An attacker can reallocate the freed\n");
    printf("memory with controlled data.\n\n");
    
    printf("[*] Creating vulnerable scenario...\n\n");
    
    // Allocate and free a chunk
    char *chunk = malloc(64);
    printf("Allocated chunk at: 0x%lx\n", (unsigned long)chunk);
    
    // Store some data
    strcpy(chunk, "Original data");
    printf("Data before free: %s\n", chunk);
    
    // Free the chunk
    free(chunk);
    printf("\n[!] Chunk freed but pointer still exists (dangling pointer)\n\n");
    
    printf("In a real exploit scenario:\n");
    printf("1. Attacker triggers a free() of object\n");
    printf("2. Attacker sprays heap to reallocate that address\n");
    printf("3. Freed object is reallocated with attacker data\n");
    printf("4. Program uses dangling pointer, executing attacker code\n\n");
    
    // Simulate reallocation (would be attacker-controlled)
    char *new_chunk = malloc(64);
    printf("New allocation at: 0x%lx ", (unsigned long)new_chunk);
    
    if (new_chunk == chunk) {
        printf("(SAME ADDRESS - reused!)\n");
        strcpy(new_chunk, "Attacker controlled!");
        printf("New data: %s\n\n", new_chunk);
    } else {
        printf("(different address)\n\n");
    }
    
    printf("WHY HEAP SPRAY HELPS:\n");
    printf("1. Increases chance of reallocating freed object\n");
    printf("2. Places attacker data where freed object was\n");
    printf("3. Converts memory reuse into code execution\n\n");
    
    // Clean up (if different address)
    if (new_chunk != chunk) {
        free(new_chunk);
    } else {
        free(new_chunk);
    }
}

void demonstrate_double_free(void) {
    printf("\n===== DOUBLE-FREE VULNERABILITY =====\n\n");
    
    printf("Double-free occurs when free() is called twice on the same pointer.\n");
    printf("This corrupts the allocator's free list, potentially allowing\n");
    printf("arbitrary writes or code execution.\n\n");
    
    printf("[*] Creating vulnerable scenario...\n\n");
    
    char *chunk = malloc(64);
    printf("Allocated chunk at: 0x%lx\n", (unsigned long)chunk);
    strcpy(chunk, "Data");
    
    printf("\n[*] First free() - normal\n");
    free(chunk);
    
    printf("\n[!] Second free() on same pointer would cause:\n");
    printf("1. Corruption of allocator's free list\n");
    printf("2. Same chunk returned twice by malloc()\n");
    printf("3. Two pointers pointing to same memory\n");
    printf("4. Writes through one pointer affect the other\n\n");
    
    printf("WHY HEAP SPRAY HELPS:\n");
    printf("1. Fills free list with controlled allocations\n");
    printf("2. Exploits corrupted free list structure\n");
    printf("3. Enables overlapping chunks attack\n");
    printf("4. Creates opportunities for arbitrary write\n\n");
    
    // Note: We don't actually call free() again to avoid crashing
}

void demonstrate_metadata_corruption(void) {
    printf("\n===== HEAP METADATA CORRUPTION =====\n\n");
    
    printf("Heap allocators store metadata before each chunk (size, flags, etc.).\n");
    printf("Corrupting this metadata can lead to powerful exploitation primitives.\n\n");
    
    printf("[*] Typical chunk structure:\n");
    printf("┌─────────────────┐\n");
    printf("│ Previous Size   │  ← Metadata\n");
    printf("│ Chunk Size      │  ← Metadata\n");
    printf("├─────────────────┤\n");
    printf("│                 │\n");
    printf("│   User Data     │  ← Your allocation\n");
    printf("│                 │\n");
    printf("├─────────────────┤\n");
    printf("│ Next Metadata   │\n");
    printf("└─────────────────┘\n\n");
    
    printf("Overflow attacks can corrupt:\n");
    printf("- Size field → control allocator behavior\n");
    printf("- Forward/backward pointers → unlink exploit\n");
    printf("- Flags → bypass security checks\n\n");
    
    printf("WHY HEAP SPRAY HELPS:\n");
    printf("1. Surrounds vulnerable chunk with controlled data\n");
    printf("2. Ensures overflow lands in predictable location\n");
    printf("3. Provides fake metadata structures\n");
    printf("4. Increases reliability of unlink exploits\n\n");
}

void demonstrate_exploitation_flow(void) {
    printf("\n===== COMPLETE EXPLOITATION FLOW =====\n\n");
    
    printf("Typical heap exploitation with spray:\n\n");
    
    printf("Step 1: HEAP SPRAY\n");
    printf("  └─ Allocate many chunks with attacker-controlled data\n");
    printf("  └─ Create predictable memory layout\n");
    heap_spray_result_t *spray = heap_spray_basic(4096, 50, NULL, 0);
    
    printf("\nStep 2: HEAP GROOMING\n");
    printf("  └─ Create specific holes in heap\n");
    printf("  └─ Prepare for vulnerable allocation\n");
    
    printf("\nStep 3: TRIGGER VULNERABILITY\n");
    printf("  └─ Cause overflow/UAF/double-free\n");
    printf("  └─ Corrupt adjacent memory or metadata\n");
    
    printf("\nStep 4: EXPLOIT\n");
    printf("  └─ Leverage corrupted state\n");
    printf("  └─ Achieve code execution or arbitrary read/write\n\n");
    
    if (spray) {
        printf("Spray statistics:\n");
        heap_spray_print_stats(spray);
        heap_spray_cleanup(spray);
    }
    
    printf("This is why heap spraying is so common:\n");
    printf("✓ Makes exploits more reliable\n");
    printf("✓ Reduces address space randomization impact\n");
    printf("✓ Provides attacker-controlled landing zones\n");
    printf("✓ Works across different allocator versions\n\n");
}

int main(void) {
    printf("\n");
    printf("╔═══════════════════════════════════════════════════════════╗\n");
    printf("║      HEAP VULNERABILITY EXPLOITATION DEMONSTRATION       ║\n");
    printf("║                                                           ║\n");
    printf("║  This demo shows why heap spraying is so common in       ║\n");
    printf("║  modern exploitation. It demonstrates various heap       ║\n");
    printf("║  vulnerabilities and how spraying makes them easier      ║\n");
    printf("║  to exploit.                                             ║\n");
    printf("║                                                           ║\n");
    printf("║  FOR EDUCATIONAL PURPOSES ONLY                           ║\n");
    printf("╚═══════════════════════════════════════════════════════════╝\n");
    
    // Run demonstrations
    demonstrate_heap_overflow();
    demonstrate_use_after_free();
    demonstrate_double_free();
    demonstrate_metadata_corruption();
    demonstrate_exploitation_flow();
    
    printf("\n");
    printf("══════════════════════════════════════════════════════════\n");
    printf("Key Insights:\n\n");
    printf("Heap Spraying is Common Because:\n");
    printf("1. Makes exploitation deterministic and reliable\n");
    printf("2. Defeats ASLR by filling address space\n");
    printf("3. Works with various heap vulnerabilities\n");
    printf("4. Simple to implement but very effective\n");
    printf("5. Core technique in modern exploit development\n\n");
    printf("Defense Mechanisms:\n");
    printf("- ASLR (Address Space Layout Randomization)\n");
    printf("- Heap canaries and checksums\n");
    printf("- Safe unlinking checks\n");
    printf("- Hardened allocators (tcmalloc, jemalloc)\n");
    printf("- Memory tagging (ARM MTE)\n");
    printf("══════════════════════════════════════════════════════════\n\n");
    
    return 0;
}
