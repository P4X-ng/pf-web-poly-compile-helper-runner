// Use-After-Free vulnerability practice binary
// Purpose: Learn UAF exploitation techniques
// Vulnerability: Using freed memory

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    char data[32];
    void (*handler)();
} Object;

void normal_handler() {
    printf("Normal handler called.\n");
}

void secret_handler() {
    printf("\nðŸ’Ž SECRET HANDLER ACTIVATED! ðŸ’Ž\n");
    printf("Use-After-Free exploitation successful!\n");
    system("/bin/sh");
}

Object *global_obj = NULL;

void create_object(char *data) {
    global_obj = (Object*)malloc(sizeof(Object));
    if (!global_obj) {
        printf("Allocation failed!\n");
        return;
    }
    
    strncpy(global_obj->data, data, sizeof(global_obj->data) - 1);
    global_obj->handler = normal_handler;
    
    printf("Created object at: %p\n", (void*)global_obj);
    printf("Handler at: %p, points to: %p\n", 
           (void*)&global_obj->handler, (void*)global_obj->handler);
}

void delete_object() {
    if (global_obj) {
        printf("Freeing object at: %p\n", (void*)global_obj);
        free(global_obj);
        // VULNERABILITY: Not setting to NULL after free
        printf("Object freed (but pointer not nulled!)\n");
    }
}

void use_object() {
    if (global_obj) {
        printf("Using object at: %p\n", (void*)global_obj);
        printf("Data: %s\n", global_obj->data);
        printf("Calling handler at: %p\n", (void*)global_obj->handler);
        // VULNERABILITY: Using after free
        global_obj->handler();
    }
}

void allocate_evil(char *data) {
    // Allocate same size to potentially reuse freed memory
    void *evil = malloc(sizeof(Object));
    printf("Allocated evil object at: %p\n", evil);
    
    // Write evil data
    memcpy(evil, data, sizeof(Object));
}

int main(int argc, char *argv[]) {
    printf("=== Use-After-Free Practice ===\n");
    printf("Secret handler at: %p\n", (void*)secret_handler);
    printf("Normal handler at: %p\n", (void*)normal_handler);
    
    if (argc < 2) {
        printf("\nUsage: %s <command>\n", argv[0]);
        printf("Commands:\n");
        printf("  create <data>  - Create object with data\n");
        printf("  delete         - Free the object\n");
        printf("  use            - Use the object (UAF if freed)\n");
        printf("  evil <hex>     - Allocate with custom data\n");
        printf("\nPractice objectives:\n");
        printf("1. Create object, delete it, then use it (UAF)\n");
        printf("2. Allocate new data to fill freed memory\n");
        printf("3. Control freed memory to hijack handler pointer\n");
        return 1;
    }
    
    if (strcmp(argv[1], "create") == 0 && argc > 2) {
        create_object(argv[2]);
    } else if (strcmp(argv[1], "delete") == 0) {
        delete_object();
    } else if (strcmp(argv[1], "use") == 0) {
        use_object();
    } else if (strcmp(argv[1], "evil") == 0 && argc > 2) {
        allocate_evil(argv[2]);
    } else {
        printf("Invalid command!\n");
    }
    
    return 0;
}
