#!/usr/bin/env python3
"""
Complexity Analyzer
Detects functions with high complexity that are potential vulnerability hotspots:
- Large blocks with many if/else statements
- Functions that go on forever (very long functions)
- High cyclomatic complexity
"""

import sys
import json
import re
import subprocess
from pathlib import Path
from collections import defaultdict

try:
    import r2pipe
    R2_AVAILABLE = True
except ImportError:
    R2_AVAILABLE = False


class ComplexityAnalyzer:
    """Analyze function complexity for vulnerability research"""
    
    # Thresholds for flagging functions
    THRESHOLDS = {
        'large_function': 2000,        # bytes
        'very_large_function': 5000,   # bytes
        'many_blocks': 30,             # basic blocks
        'extreme_blocks': 50,          # basic blocks
        'high_complexity': 20,         # cyclomatic complexity
        'extreme_complexity': 40,      # cyclomatic complexity
        'many_calls': 50,              # function calls
        'many_jumps': 30,              # conditional jumps (if statements)
    }
    
    def __init__(self, binary_path):
        self.binary_path = Path(binary_path)
        self.functions = []
        self.hotspots = []
        
        if not self.binary_path.exists():
            raise FileNotFoundError(f"Binary not found: {binary_path}")
        
        if not R2_AVAILABLE:
            print("[!] Warning: r2pipe not available. Install with: pip install r2pipe")
            print("[!] Limited analysis will be performed without radare2")
    
    def analyze_with_radare2(self):
        """Deep analysis with radare2"""
        if not R2_AVAILABLE:
            return []
        
        results = []
        print(f"[*] Performing deep complexity analysis with radare2...")
        
        try:
            r2 = r2pipe.open(str(self.binary_path))
            
            # Analyze all functions
            print(f"[*] Running auto-analysis (this may take a moment)...")
            r2.cmd('aaa')
            
            # Get all functions
            functions = r2.cmdj('aflj')
            
            if not functions:
                print(f"[!] No functions found in binary")
                r2.quit()
                return results
            
            print(f"[+] Found {len(functions)} functions, analyzing complexity...")
            
            for i, func in enumerate(functions):
                if (i + 1) % 50 == 0:
                    print(f"[*] Progress: {i+1}/{len(functions)} functions analyzed", end='\r', flush=True)
                
                func_name = func.get('name', '')
                func_addr = func.get('offset', 0)
                func_size = func.get('size', 0)
                
                # Get basic blocks
                blocks = r2.cmdj(f'afbj @ {func_addr}')
                block_count = len(blocks) if blocks else 0
                
                # Get cyclomatic complexity
                complexity_info = r2.cmdj(f'afCj @ {func_addr}')
                cyclomatic = complexity_info.get('complexity', 0) if complexity_info else 0
                
                # Get function info for call analysis
                func_info = r2.cmdj(f'afij @ {func_addr}')
                
                if func_info and len(func_info) > 0:
                    fi = func_info[0]
                    call_count = fi.get('ncalls', 0)
                    xref_count = fi.get('nrefs', 0)
                else:
                    call_count = 0
                    xref_count = 0
                
                # Count conditional jumps (approximates if statements)
                disasm = r2.cmd(f'pdf @ {func_addr}')
                jump_count = disasm.count('je ') + disasm.count('jne ') + disasm.count('jg ') + \
                           disasm.count('jl ') + disasm.count('jge ') + disasm.count('jle ') + \
                           disasm.count('ja ') + disasm.count('jb ') + disasm.count('jz ') + \
                           disasm.count('jnz ')
                
                # Calculate metrics
                metrics = {
                    'name': func_name,
                    'address': hex(func_addr),
                    'size': func_size,
                    'blocks': block_count,
                    'cyclomatic_complexity': cyclomatic,
                    'calls': call_count,
                    'xrefs': xref_count,
                    'conditional_jumps': jump_count
                }
                
                # Identify complexity indicators
                indicators = self.identify_complexity_indicators(metrics)
                if indicators:
                    metrics['indicators'] = indicators
                    metrics['risk_score'] = self.calculate_risk_score(metrics)
                
                results.append(metrics)
            
            print()  # New line after progress
            r2.quit()
            
        except (subprocess.SubprocessError, OSError, Exception) as e:
            print(f"\n[!] Error during radare2 analysis: {e}")
            import traceback
            traceback.print_exc()
        
        return results
    
    def analyze_with_objdump(self):
        """Fallback analysis with objdump"""
        print(f"[*] Analyzing with objdump (limited functionality)...")
        
        results = []
        try:
            result = subprocess.run(
                ['objdump', '-d', str(self.binary_path)],
                capture_output=True,
                text=True,
                timeout=120
            )
            
            current_func = None
            func_start = 0
            func_instructions = []
            
            for line in result.stdout.split('\n'):
                # Detect function start
                func_match = re.match(r'^([0-9a-f]+) <(.+)>:', line)
                if func_match:
                    # Save previous function
                    if current_func:
                        metrics = self.analyze_function_disasm(
                            current_func, func_start, func_instructions
                        )
                        if metrics:
                            results.append(metrics)
                    
                    # Start new function
                    func_start = int(func_match.group(1), 16)
                    current_func = func_match.group(2)
                    func_instructions = []
                
                # Collect instructions
                elif current_func and line.strip():
                    if re.match(r'\s+[0-9a-f]+:', line):
                        func_instructions.append(line)
            
            # Save last function
            if current_func:
                metrics = self.analyze_function_disasm(
                    current_func, func_start, func_instructions
                )
                if metrics:
                    results.append(metrics)
            
            print(f"[+] Analyzed {len(results)} functions")
            
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError) as e:
            print(f"[!] Error during objdump analysis: {e}")
        
        return results
    
    def analyze_function_disasm(self, name, start_addr, instructions):
        """Analyze function from disassembly"""
        if not instructions:
            return None
        
        # Estimate size
        size = len(instructions) * 4  # Rough estimate
        
        # Count jumps
        jump_count = sum(1 for line in instructions if re.search(r'\bj[a-z]+\b', line))
        
        # Count calls
        call_count = sum(1 for line in instructions if 'call' in line)
        
        # Estimate blocks (jumps + 1)
        block_count = jump_count + 1
        
        # Estimate cyclomatic complexity (edges - nodes + 2)
        # Rough approximation: jumps + 1
        cyclomatic = jump_count + 1
        
        metrics = {
            'name': name,
            'address': hex(start_addr),
            'size': size,
            'blocks': block_count,
            'cyclomatic_complexity': cyclomatic,
            'calls': call_count,
            'xrefs': 0,  # Not available from objdump
            'conditional_jumps': jump_count
        }
        
        # Identify complexity indicators
        indicators = self.identify_complexity_indicators(metrics)
        if indicators:
            metrics['indicators'] = indicators
            metrics['risk_score'] = self.calculate_risk_score(metrics)
        
        return metrics
    
    def identify_complexity_indicators(self, metrics):
        """Identify complexity indicators based on metrics"""
        indicators = []
        
        # Size-based indicators
        if metrics['size'] >= self.THRESHOLDS['very_large_function']:
            indicators.append('very_large_function')
        elif metrics['size'] >= self.THRESHOLDS['large_function']:
            indicators.append('large_function')
        
        # Block-based indicators
        if metrics['blocks'] >= self.THRESHOLDS['extreme_blocks']:
            indicators.append('extreme_control_flow')
        elif metrics['blocks'] >= self.THRESHOLDS['many_blocks']:
            indicators.append('complex_control_flow')
        
        # Complexity indicators
        if metrics['cyclomatic_complexity'] >= self.THRESHOLDS['extreme_complexity']:
            indicators.append('extreme_complexity')
        elif metrics['cyclomatic_complexity'] >= self.THRESHOLDS['high_complexity']:
            indicators.append('high_complexity')
        
        # Jump-based indicators (if/else statements)
        if metrics['conditional_jumps'] >= self.THRESHOLDS['many_jumps']:
            indicators.append('many_if_statements')
        
        # Call-based indicators
        if metrics['calls'] >= self.THRESHOLDS['many_calls']:
            indicators.append('many_function_calls')
        
        return indicators
    
    def calculate_risk_score(self, metrics):
        """Calculate risk score based on complexity metrics"""
        score = 0
        
        # Size contributes to score
        score += min(metrics['size'] / 1000, 10)
        
        # Blocks contribute heavily
        score += min(metrics['blocks'] * 0.5, 20)
        
        # Cyclomatic complexity is key
        score += min(metrics['cyclomatic_complexity'], 30)
        
        # Many jumps = many if statements = bugs
        score += min(metrics['conditional_jumps'] * 0.5, 15)
        
        # Many calls = complex interactions
        score += min(metrics['calls'] * 0.2, 10)
        
        return round(score, 2)
    
    def find_hotspots(self):
        """Identify top vulnerability hotspots"""
        print(f"\n[*] Identifying vulnerability hotspots...")
        
        # Get functions with indicators
        hotspots = [f for f in self.functions if f.get('indicators')]
        
        # Sort by risk score
        hotspots = sorted(hotspots, key=lambda x: x.get('risk_score', 0), reverse=True)
        
        self.hotspots = hotspots
        return hotspots
    
    def print_results(self):
        """Print analysis results"""
        print(f"\n{'='*70}")
        print(f"COMPLEXITY ANALYSIS RESULTS")
        print(f"{'='*70}")
        
        if not self.functions:
            print(f"\n[!] No functions analyzed")
            return
        
        print(f"\n[+] Analyzed {len(self.functions)} functions")
        
        # Statistics
        with_indicators = [f for f in self.functions if f.get('indicators')]
        print(f"[+] Found {len(with_indicators)} functions with complexity indicators")
        
        if not with_indicators:
            print(f"\n[*] No complex functions found above thresholds")
            return
        
        # Top hotspots
        top_hotspots = self.hotspots[:10]
        
        print(f"\n{'='*70}")
        print(f"TOP VULNERABILITY HOTSPOTS (by risk score)")
        print(f"{'='*70}")
        
        for i, func in enumerate(top_hotspots, 1):
            print(f"\n{i}. {func['name']}")
            print(f"   Address: {func['address']}")
            print(f"   Risk Score: {func['risk_score']}/100")
            print(f"   Size: {func['size']} bytes")
            print(f"   Basic Blocks: {func['blocks']}")
            print(f"   Cyclomatic Complexity: {func['cyclomatic_complexity']}")
            print(f"   Conditional Jumps (if statements): {func['conditional_jumps']}")
            print(f"   Function Calls: {func['calls']}")
            print(f"   Indicators: {', '.join(func['indicators'])}")
        
        # Category breakdown
        print(f"\n{'='*70}")
        print(f"COMPLEXITY CATEGORIES")
        print(f"{'='*70}")
        
        categories = defaultdict(list)
        for func in with_indicators:
            for indicator in func['indicators']:
                categories[indicator].append(func['name'])
        
        for category, funcs in sorted(categories.items()):
            print(f"\n{category.replace('_', ' ').title()}: {len(funcs)} functions")
            for name in funcs[:5]:
                print(f"  - {name}")
            if len(funcs) > 5:
                print(f"  ... and {len(funcs) - 5} more")
        
        # Fuzzing recommendations
        print(f"\n{'='*70}")
        print(f"FUZZING RECOMMENDATIONS")
        print(f"{'='*70}")
        
        print(f"\n[*] Priority targets for fuzzing:")
        for func in top_hotspots[:5]:
            print(f"    - {func['name']} (risk: {func['risk_score']})")
        
        print(f"\n[*] These functions are likely to contain bugs due to:")
        print(f"    - High complexity (many execution paths)")
        print(f"    - Large size (more code = more bugs)")
        print(f"    - Many conditional branches (edge cases)")
        
        print(f"\n[*] Recommended approach:")
        print(f"    1. Use parse function detector to find input sources")
        print(f"    2. Set breakpoints on hotspot functions")
        print(f"    3. Use in-memory fuzzing for fast iteration")
        print(f"    pf fuzz-in-memory binary={self.binary_path}")
    
    def export_json(self, output_path):
        """Export results as JSON"""
        data = {
            'binary': str(self.binary_path),
            'thresholds': self.THRESHOLDS,
            'total_functions': len(self.functions),
            'complex_functions': len([f for f in self.functions if f.get('indicators')]),
            'hotspots': self.hotspots[:20],  # Top 20
            'all_functions': self.functions
        }
        
        with open(output_path, 'w') as f:
            json.dump(data, f, indent=2)
        
        print(f"\n[+] Results exported to: {output_path}")
    
    def run(self, output_json=None):
        """Run full complexity analysis"""
        print(f"\n=== Complexity Analyzer ===")
        print(f"Target: {self.binary_path}")
        
        # Try radare2 first, fall back to objdump
        if R2_AVAILABLE:
            self.functions = self.analyze_with_radare2()
        else:
            self.functions = self.analyze_with_objdump()
        
        if not self.functions:
            print(f"[!] No functions could be analyzed")
            return None
        
        self.find_hotspots()
        self.print_results()
        
        if output_json:
            self.export_json(output_json)
        
        return {
            'functions': self.functions,
            'hotspots': self.hotspots
        }


def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <binary_path> [--output output.json]")
        print(f"\nDetect complex functions that are potential vulnerability hotspots")
        print(f"\nOptions:")
        print(f"  --output FILE    Export results to JSON file")
        print(f"\nExample:")
        print(f"  {sys.argv[0]} /path/to/binary")
        print(f"  {sys.argv[0]} /path/to/binary --output complexity.json")
        sys.exit(1)
    
    binary_path = sys.argv[1]
    output_json = None
    
    # Parse arguments
    i = 2
    while i < len(sys.argv):
        if sys.argv[i] == '--output' and i + 1 < len(sys.argv):
            output_json = sys.argv[i + 1]
            i += 2
        else:
            i += 1
    
    try:
        analyzer = ComplexityAnalyzer(binary_path)
        analyzer.run(output_json=output_json)
        
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
