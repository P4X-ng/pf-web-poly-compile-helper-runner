#!/usr/bin/env python3
"""
Automagic Parse Function Detection
Automatically detects and marks parse functions in binaries for vulnerability research.

Parse functions are excellent sources for finding vulnerabilities because they:
- Handle untrusted input from various sources
- Often have complex parsing logic with edge cases
- May lack proper bounds checking
- Can contain integer overflows, buffer overflows, format string bugs
"""

import sys
import json
import re
import subprocess
from pathlib import Path
from collections import defaultdict

try:
    import r2pipe
    R2_AVAILABLE = True
except ImportError:
    R2_AVAILABLE = False


class ParseFunctionDetector:
    """Detect parse functions and vulnerable patterns in binaries"""
    
    # Common parse function patterns
    PARSE_FUNCTION_PATTERNS = {
        'string_parsing': [
            'strto', 'atoi', 'atol', 'atof', 'strtol', 'strtoul', 'strtod',
            'sscanf', 'fscanf', 'scanf', 'vsscanf', 'vfscanf',
            'parse', 'parser', 'tokenize', 'split'
        ],
        'data_deserialization': [
            'json_parse', 'xml_parse', 'yaml_parse', 'deserialize',
            'unmarshal', 'decode', 'unpack'
        ],
        'protocol_parsing': [
            'parse_header', 'parse_packet', 'parse_message', 'parse_request',
            'parse_response', 'parse_frame', 'decode_header'
        ],
        'buffer_manipulation': [
            'memcpy', 'memmove', 'memset', 'strcpy', 'strncpy', 'strcat',
            'strncat', 'sprintf', 'snprintf', 'vsprintf', 'vsnprintf'
        ],
        'input_handling': [
            'read', 'recv', 'recvfrom', 'fread', 'fgets', 'gets',
            'getline', 'getdelim', 'input', 'read_input'
        ]
    }
    
    # Dangerous function calls that indicate parsing
    DANGEROUS_FUNCTIONS = [
        'strcpy', 'strcat', 'sprintf', 'gets', 'scanf',
        'vsprintf', 'strncpy', 'strncat', 'memcpy'
    ]
    
    def __init__(self, binary_path, use_radare2=True):
        self.binary_path = Path(binary_path)
        self.use_radare2 = use_radare2 and R2_AVAILABLE
        self.parse_functions = []
        self.vulnerable_patterns = []
        
        if not self.binary_path.exists():
            raise FileNotFoundError(f"Binary not found: {binary_path}")
    
    def detect_with_nm(self):
        """Use nm to detect function symbols"""
        results = []
        try:
            result = subprocess.run(
                ['nm', '-D', str(self.binary_path)],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            symbols = result.stdout.strip().split('\n')
            for symbol in symbols:
                parts = symbol.split()
                if len(parts) >= 3:
                    func_name = parts[-1]
                    results.append(func_name)
            
        except (subprocess.TimeoutExpired, FileNotFoundError):
            # Try without -D flag (for static binaries)
            try:
                result = subprocess.run(
                    ['nm', str(self.binary_path)],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                
                symbols = result.stdout.strip().split('\n')
                for symbol in symbols:
                    parts = symbol.split()
                    if len(parts) >= 3 and parts[1] in ['T', 't']:
                        func_name = parts[-1]
                        results.append(func_name)
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
                pass
        
        return results
    
    def detect_with_objdump(self):
        """Use objdump to disassemble and analyze"""
        results = []
        try:
            result = subprocess.run(
                ['objdump', '-d', str(self.binary_path)],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            # Look for function headers and calls
            for line in result.stdout.split('\n'):
                # Match function definitions
                if re.match(r'^[0-9a-f]+ <.*>:', line):
                    match = re.search(r'<(.+)>:', line)
                    if match:
                        func_name = match.group(1)
                        results.append(func_name)
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
            pass
        
        return results
    
    def detect_with_radare2(self):
        """Use radare2 for deep analysis"""
        if not R2_AVAILABLE:
            return []
        
        results = []
        try:
            r2 = r2pipe.open(str(self.binary_path))
            
            # Analyze
            r2.cmd('aaa')
            
            # Get all functions
            functions = r2.cmdj('aflj')
            
            if functions:
                for func in functions:
                    func_name = func.get('name', '')
                    func_size = func.get('size', 0)
                    func_addr = func.get('offset', 0)
                    
                    # Get cross-references
                    xrefs = r2.cmdj(f'axtj @ {func_addr}')
                    xref_count = len(xrefs) if xrefs else 0
                    
                    # Get basic blocks
                    blocks = r2.cmdj(f'afbj @ {func_addr}')
                    block_count = len(blocks) if blocks else 0
                    
                    results.append({
                        'name': func_name,
                        'address': hex(func_addr),
                        'size': func_size,
                        'xrefs': xref_count,
                        'blocks': block_count
                    })
            
            r2.quit()
        except Exception as e:
            print(f"[!] Radare2 analysis failed: {e}")
        
        return results
    
    def classify_function(self, func_name):
        """Classify function as parse function"""
        func_lower = func_name.lower()
        
        categories = []
        for category, patterns in self.PARSE_FUNCTION_PATTERNS.items():
            for pattern in patterns:
                if pattern in func_lower:
                    categories.append(category)
                    break
        
        return categories
    
    def analyze_function_complexity(self, func_info):
        """Analyze function complexity for vulnerability indicators"""
        indicators = []
        
        # Large function size (more code = more bugs)
        if func_info.get('size', 0) > 1000:
            indicators.append('large_function')
        
        # High number of basic blocks (complex control flow)
        if func_info.get('blocks', 0) > 20:
            indicators.append('complex_control_flow')
        
        # High number of cross-references (heavily used)
        if func_info.get('xrefs', 0) > 10:
            indicators.append('frequently_called')
        
        return indicators
    
    def detect_parse_functions(self):
        """Main detection routine"""
        print(f"\n=== Parse Function Detection ===")
        print(f"Target: {self.binary_path}")
        print(f"Using radare2: {self.use_radare2}")
        
        all_functions = []
        
        # Try multiple methods
        print(f"\n[*] Detecting functions with nm...")
        nm_funcs = self.detect_with_nm()
        print(f"[+] Found {len(nm_funcs)} symbols")
        
        print(f"\n[*] Detecting functions with objdump...")
        objdump_funcs = self.detect_with_objdump()
        print(f"[+] Found {len(objdump_funcs)} functions")
        
        # Combine function names
        func_names = set(nm_funcs + objdump_funcs)
        
        # Use radare2 for detailed analysis if available
        detailed_funcs = {}
        if self.use_radare2:
            print(f"\n[*] Performing deep analysis with radare2...")
            r2_results = self.detect_with_radare2()
            print(f"[+] Analyzed {len(r2_results)} functions")
            
            for func in r2_results:
                detailed_funcs[func['name']] = func
        
        # Classify all functions
        print(f"\n[*] Classifying functions...")
        parse_functions = []
        
        for func_name in func_names:
            categories = self.classify_function(func_name)
            
            if categories:
                func_info = {
                    'name': func_name,
                    'categories': categories,
                    'priority': 'high' if any(cat in ['string_parsing', 'input_handling'] for cat in categories) else 'medium'
                }
                
                # Add detailed info if available
                if func_name in detailed_funcs:
                    detail = detailed_funcs[func_name]
                    func_info.update({
                        'address': detail.get('address'),
                        'size': detail.get('size'),
                        'complexity_indicators': self.analyze_function_complexity(detail)
                    })
                
                parse_functions.append(func_info)
        
        self.parse_functions = sorted(
            parse_functions,
            key=lambda x: (x['priority'] == 'high', len(x['categories']), x.get('size', 0)),
            reverse=True
        )
        
        return self.parse_functions
    
    def detect_vulnerable_patterns(self):
        """Detect vulnerable patterns in parse functions"""
        print(f"\n[*] Detecting vulnerable patterns...")
        
        patterns = []
        
        # Look for dangerous function combinations
        dangerous_found = []
        all_names = [f['name'].lower() for f in self.parse_functions]
        
        for dangerous in self.DANGEROUS_FUNCTIONS:
            if any(dangerous in name for name in all_names):
                dangerous_found.append(dangerous)
        
        if dangerous_found:
            patterns.append({
                'type': 'dangerous_functions',
                'functions': dangerous_found,
                'severity': 'high',
                'description': 'Functions known to be dangerous if misused'
            })
        
        # Look for parse + buffer manipulation combos
        has_parsing = any('string_parsing' in f['categories'] for f in self.parse_functions)
        has_buffer_ops = any('buffer_manipulation' in f['categories'] for f in self.parse_functions)
        
        if has_parsing and has_buffer_ops:
            patterns.append({
                'type': 'parse_and_buffer_manipulation',
                'severity': 'high',
                'description': 'Binary contains both parsing and buffer manipulation - high risk of buffer overflow'
            })
        
        # Look for input + parsing combo
        has_input = any('input_handling' in f['categories'] for f in self.parse_functions)
        if has_input and has_parsing:
            patterns.append({
                'type': 'input_parsing_pipeline',
                'severity': 'critical',
                'description': 'Direct pipeline from input to parsing - prime target for fuzzing'
            })
        
        self.vulnerable_patterns = patterns
        return patterns
    
    def print_results(self):
        """Print detection results"""
        print(f"\n{'='*60}")
        print(f"PARSE FUNCTION DETECTION RESULTS")
        print(f"{'='*60}")
        
        if not self.parse_functions:
            print(f"\n[!] No parse functions detected")
            return
        
        print(f"\n[+] Detected {len(self.parse_functions)} parse functions")
        
        # Group by priority
        high_priority = [f for f in self.parse_functions if f['priority'] == 'high']
        medium_priority = [f for f in self.parse_functions if f['priority'] == 'medium']
        
        if high_priority:
            print(f"\n--- HIGH PRIORITY ({len(high_priority)}) ---")
            for func in high_priority[:10]:  # Show top 10
                print(f"\n  Function: {func['name']}")
                print(f"  Categories: {', '.join(func['categories'])}")
                if 'address' in func:
                    print(f"  Address: {func['address']}")
                if 'size' in func:
                    print(f"  Size: {func['size']} bytes")
                if 'complexity_indicators' in func and func['complexity_indicators']:
                    print(f"  Complexity: {', '.join(func['complexity_indicators'])}")
            
            if len(high_priority) > 10:
                print(f"\n  ... and {len(high_priority) - 10} more high priority functions")
        
        if medium_priority:
            print(f"\n--- MEDIUM PRIORITY ({len(medium_priority)}) ---")
            for func in medium_priority[:5]:  # Show top 5
                print(f"  - {func['name']} ({', '.join(func['categories'])})")
            
            if len(medium_priority) > 5:
                print(f"  ... and {len(medium_priority) - 5} more")
        
        # Print vulnerable patterns
        if self.vulnerable_patterns:
            print(f"\n{'='*60}")
            print(f"VULNERABLE PATTERNS DETECTED")
            print(f"{'='*60}")
            
            for pattern in self.vulnerable_patterns:
                print(f"\n[!] {pattern['type'].upper()}")
                print(f"    Severity: {pattern['severity'].upper()}")
                print(f"    Description: {pattern['description']}")
                if 'functions' in pattern:
                    print(f"    Functions: {', '.join(pattern['functions'])}")
        
        # Fuzzing recommendations
        print(f"\n{'='*60}")
        print(f"FUZZING RECOMMENDATIONS")
        print(f"{'='*60}")
        
        if high_priority:
            print(f"\n[*] Recommended targets for fuzzing:")
            for func in high_priority[:5]:
                print(f"    - {func['name']}")
            
            print(f"\n[*] Suggested fuzzing commands:")
            print(f"    pf fuzz-basic binary={self.binary_path} iterations=10000")
            print(f"    pf fuzz-parallel binary={self.binary_path} workers=8 iterations=100000")
            
            if any('input_handling' in f['categories'] for f in high_priority):
                print(f"\n[*] Use in-memory fuzzing for speed:")
                print(f"    pf fuzz-in-memory binary={self.binary_path}")
    
    def export_json(self, output_path):
        """Export results as JSON"""
        data = {
            'binary': str(self.binary_path),
            'parse_functions': self.parse_functions,
            'vulnerable_patterns': self.vulnerable_patterns,
            'statistics': {
                'total_functions': len(self.parse_functions),
                'high_priority': len([f for f in self.parse_functions if f['priority'] == 'high']),
                'medium_priority': len([f for f in self.parse_functions if f['priority'] == 'medium'])
            }
        }
        
        with open(output_path, 'w') as f:
            json.dump(data, f, indent=2)
        
        print(f"\n[+] Results exported to: {output_path}")
    
    def run(self, output_json=None):
        """Run full detection pipeline"""
        self.detect_parse_functions()
        self.detect_vulnerable_patterns()
        self.print_results()
        
        if output_json:
            self.export_json(output_json)
        
        return {
            'functions': self.parse_functions,
            'patterns': self.vulnerable_patterns
        }


def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <binary_path> [--output output.json] [--no-r2]")
        print(f"\nAutomagically detect parse functions for vulnerability research")
        print(f"\nOptions:")
        print(f"  --output FILE    Export results to JSON file")
        print(f"  --no-r2          Disable radare2 analysis")
        print(f"\nExample:")
        print(f"  {sys.argv[0]} /path/to/binary")
        print(f"  {sys.argv[0]} /path/to/binary --output results.json")
        sys.exit(1)
    
    binary_path = sys.argv[1]
    output_json = None
    use_radare2 = True
    
    # Parse arguments
    i = 2
    while i < len(sys.argv):
        if sys.argv[i] == '--output' and i + 1 < len(sys.argv):
            output_json = sys.argv[i + 1]
            i += 2
        elif sys.argv[i] == '--no-r2':
            use_radare2 = False
            i += 1
        else:
            i += 1
    
    try:
        detector = ParseFunctionDetector(binary_path, use_radare2=use_radare2)
        detector.run(output_json=output_json)
        
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
