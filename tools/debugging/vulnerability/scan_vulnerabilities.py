#!/usr/bin/env python3
"""Vulnerability Scanner"""
import sys
import subprocess
import re
from pathlib import Path

def scan_vulnerabilities(binary_path):
    """Enhanced vulnerability scanner"""
    print(f"[*] Scanning {binary_path} for vulnerabilities")
    
    binary = Path(binary_path)
    if not binary.exists():
        print(f"[!] Binary not found: {binary_path}")
        return
    
    findings = []
    
    # Check for dangerous function imports
    print(f"\n[1/5] Checking for dangerous function imports...")
    dangerous_funcs = scan_dangerous_functions(binary_path)
    if dangerous_funcs:
        findings.extend(dangerous_funcs)
        print(f"[!] Found {len(dangerous_funcs)} dangerous function imports")
    else:
        print(f"[+] No dangerous function imports found")
    
    # Check for format string vulnerabilities
    print(f"\n[2/5] Checking for format string patterns...")
    format_issues = scan_format_strings(binary_path)
    if format_issues:
        findings.extend(format_issues)
        print(f"[!] Found {len(format_issues)} potential format string issues")
    else:
        print(f"[+] No obvious format string issues")
    
    # Check security features
    print(f"\n[3/5] Checking security features...")
    security_features = check_security_features(binary_path)
    print(f"[+] Security features: {', '.join(security_features) if security_features else 'None'}")
    
    # Check for buffer operations
    print(f"\n[4/5] Checking for unsafe buffer operations...")
    buffer_ops = scan_buffer_operations(binary_path)
    if buffer_ops:
        findings.extend(buffer_ops)
        print(f"[!] Found {len(buffer_ops)} potentially unsafe buffer operations")
    else:
        print(f"[+] No obvious unsafe buffer operations")
    
    # String analysis
    print(f"\n[5/5] Analyzing strings for secrets/patterns...")
    string_issues = scan_strings(binary_path)
    if string_issues:
        findings.extend(string_issues)
        print(f"[!] Found {len(string_issues)} interesting strings")
    
    # Summary
    print(f"\n{'='*60}")
    print(f"VULNERABILITY SCAN SUMMARY")
    print(f"{'='*60}")
    print(f"Total findings: {len(findings)}")
    
    if findings:
        print(f"\nDetailed findings:")
        for i, finding in enumerate(findings, 1):
            print(f"\n{i}. {finding['type']}")
            print(f"   Severity: {finding['severity']}")
            print(f"   Description: {finding['description']}")
            if 'location' in finding:
                print(f"   Location: {finding['location']}")
    
    print(f"\n{'='*60}")
    print(f"RECOMMENDATIONS")
    print(f"{'='*60}")
    print(f"1. Use parse function detector to find input sources")
    print(f"2. Run complexity analyzer to find complex code")
    print(f"3. Use in-memory fuzzing for fast vulnerability discovery")
    print(f"   pf kernel-automagic-analysis binary={binary_path}")
    
    return findings

def scan_dangerous_functions(binary_path):
    """Scan for dangerous function imports"""
    dangerous = {
        'strcpy': 'high',
        'strcat': 'high', 
        'sprintf': 'high',
        'gets': 'critical',
        'scanf': 'high',
        'vsprintf': 'high',
        'strncpy': 'medium',
        'strncat': 'medium',
        'system': 'high',
        'popen': 'high',
        'exec': 'high'
    }
    
    findings = []
    
    try:
        # Use nm to get symbols
        result = subprocess.run(
            ['nm', '-D', binary_path],
            capture_output=True,
            text=True,
            timeout=30
        )
        
        for line in result.stdout.split('\n'):
            for func, severity in dangerous.items():
                if func in line:
                    findings.append({
                        'type': 'Dangerous Function',
                        'severity': severity,
                        'description': f"Use of {func} can lead to buffer overflows",
                        'location': func
                    })
    except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError) as e:
        # nm might not be available or binary format not supported
        pass
    
    return findings

def scan_format_strings(binary_path):
    """Scan for format string vulnerabilities"""
    findings = []
    
    try:
        result = subprocess.run(
            ['objdump', '-d', binary_path],
            capture_output=True,
            text=True,
            timeout=60
        )
        
        # Look for printf-family calls
        printf_calls = ['printf', 'fprintf', 'sprintf', 'snprintf', 'syslog']
        
        for line in result.stdout.split('\n'):
            for func in printf_calls:
                if f'call.*{func}' in line or f'{func}@plt' in line:
                    findings.append({
                        'type': 'Format String Function',
                        'severity': 'medium',
                        'description': f"Use of {func} - ensure format string is not user-controlled"
                    })
                    break
    except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
        # objdump might not be available
        pass
    
    return findings[:5]  # Limit to first 5

def check_security_features(binary_path):
    """Check for security features"""
    features = []
    
    try:
        result = subprocess.run(
            ['checksec', '--file', binary_path],
            capture_output=True,
            text=True,
            timeout=10
        )
        
        # Parse checksec output
        output = result.stdout.lower()
        if 'canary' in output and 'yes' in output:
            features.append('Stack Canary')
        if 'nx' in output and 'enabled' in output:
            features.append('NX')
        if 'pie' in output and 'enabled' in output:
            features.append('PIE')
        if 'relro' in output and 'full' in output:
            features.append('Full RELRO')
    except (FileNotFoundError, subprocess.CalledProcessError, subprocess.TimeoutExpired):
        # Fallback: use readelf
        try:
            result = subprocess.run(
                ['readelf', '-h', binary_path],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if 'DYN (Shared object file)' in result.stdout or 'DYN (Position-Independent Executable file)' in result.stdout:
                features.append('PIE')
        except (FileNotFoundError, subprocess.CalledProcessError, subprocess.TimeoutExpired):
            pass
    
    return features

def scan_buffer_operations(binary_path):
    """Scan for buffer operations"""
    findings = []
    
    try:
        result = subprocess.run(
            ['nm', '-D', binary_path],
            capture_output=True,
            text=True,
            timeout=30
        )
        
        buffer_funcs = {
            'memcpy': 'medium',
            'memmove': 'low',
            'strncpy': 'medium',
            'strncat': 'medium'
        }
        
        for line in result.stdout.split('\n'):
            for func, severity in buffer_funcs.items():
                if func in line:
                    findings.append({
                        'type': 'Buffer Operation',
                        'severity': severity,
                        'description': f"Use of {func} - ensure bounds are checked",
                        'location': func
                    })
    except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
        pass
    
    return findings

def scan_strings(binary_path):
    """Scan for interesting strings"""
    findings = []
    
    try:
        result = subprocess.run(
            ['strings', binary_path],
            capture_output=True,
            text=True,
            timeout=30
        )
        
        patterns = {
            'password': 'high',
            'passwd': 'high',
            'secret': 'high',
            'api_key': 'high',
            'token': 'medium',
            'debug': 'low',
            'admin': 'medium',
            'root': 'medium'
        }
        
        for line in result.stdout.split('\n'):
            line_lower = line.lower()
            for pattern, severity in patterns.items():
                if pattern in line_lower:
                    findings.append({
                        'type': 'Interesting String',
                        'severity': severity,
                        'description': f"Found '{pattern}' in binary strings",
                        'location': line[:50]
                    })
    except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
        pass
    
    return findings[:10]  # Limit to first 10

if __name__ == '__main__':
    if len(sys.argv) > 1:
        scan_vulnerabilities(sys.argv[1])
    else:
        print(f"Usage: {sys.argv[0]} <binary_path>")
        sys.exit(1)
