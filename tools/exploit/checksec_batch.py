#!/usr/bin/env python3
"""
Batch Checksec Analysis
Analyze multiple binaries and generate comprehensive security reports
"""

import os
import sys
import json
import subprocess
import argparse
from pathlib import Path
from datetime import datetime

def run_checksec(binary_path):
    """Run checksec on a single binary and parse results"""
    try:
        # Try JSON format first
        result = subprocess.run(['checksec', '--file', binary_path, '--format', 'json'], 
                              capture_output=True, text=True, timeout=30)
        
        if result.returncode == 0:
            try:
                return json.loads(result.stdout)
            except json.JSONDecodeError:
                pass
        
        # Fallback to text format
        result = subprocess.run(['checksec', '--file', binary_path], 
                              capture_output=True, text=True, timeout=30)
        
        if result.returncode == 0:
            return parse_checksec_text(result.stdout, binary_path)
        else:
            return {"error": f"checksec failed: {result.stderr}"}
            
    except subprocess.TimeoutExpired:
        return {"error": "checksec timeout"}
    except FileNotFoundError:
        return {"error": "checksec not found - run 'pf install-checksec' first"}
    except Exception as e:
        return {"error": str(e)}

def parse_checksec_text(output, binary_path):
    """Parse checksec text output into structured data"""
    result = {
        "file": binary_path,
        "relro": "No",
        "canary": "No", 
        "nx": "No",
        "pie": "No",
        "rpath": "No",
        "runpath": "No",
        "symbols": "No",
        "fortify_source": "No"
    }
    
    # Parse the output line
    if "RELRO" in output:
        if "Full RELRO" in output:
            result["relro"] = "Full"
        elif "Partial RELRO" in output:
            result["relro"] = "Partial"
    
    if "Canary found" in output:
        result["canary"] = "Yes"
    
    if "NX enabled" in output:
        result["nx"] = "Yes"
    
    if "PIE enabled" in output:
        result["pie"] = "Yes"
    elif "DSO" in output:
        result["pie"] = "DSO"
    
    if "RPATH" in output and "No RPATH" not in output:
        result["rpath"] = "Yes"
    
    if "RUNPATH" in output and "No RUNPATH" not in output:
        result["runpath"] = "Yes"
    
    if "Symbols" in output and "No Symbols" not in output:
        result["symbols"] = "Yes"
    
    if "FORTIFY" in output and "No" not in output:
        result["fortify_source"] = "Yes"
    
    return result

def get_file_info(binary_path):
    """Get additional file information"""
    try:
        stat = os.stat(binary_path)
        file_result = subprocess.run(['file', binary_path], capture_output=True, text=True)
        
        return {
            "size": stat.st_size,
            "permissions": oct(stat.st_mode)[-3:],
            "file_type": file_result.stdout.strip() if file_result.returncode == 0 else "unknown"
        }
    except Exception as e:
        return {"error": str(e)}

def find_binaries(directory):
    """Find executable files in directory"""
    binaries = []
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)
            
            # Check if file is executable
            if os.access(file_path, os.X_OK) and os.path.isfile(file_path):
                # Skip scripts and text files
                try:
                    with open(file_path, 'rb') as f:
                        header = f.read(4)
                        # Check for ELF magic number
                        if header.startswith(b'\x7fELF'):
                            binaries.append(file_path)
                except Exception:
                    continue
    
    return binaries

def analyze_directory(directory, output_dir):
    """Analyze all binaries in directory"""
    print(f"Scanning directory: {directory}")
    
    binaries = find_binaries(directory)
    print(f"Found {len(binaries)} executable files")
    
    if not binaries:
        print("No executable ELF files found")
        return
    
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    
    results = []
    
    for i, binary in enumerate(binaries, 1):
        print(f"[{i}/{len(binaries)}] Analyzing: {binary}")
        
        # Get checksec results
        checksec_result = run_checksec(binary)
        
        # Get file info
        file_info = get_file_info(binary)
        
        # Combine results
        result = {
            "binary": binary,
            "relative_path": os.path.relpath(binary, directory),
            "checksec": checksec_result,
            "file_info": file_info,
            "timestamp": datetime.now().isoformat()
        }
        
        results.append(result)
    
    # Generate reports
    generate_reports(results, output_dir, directory)

def generate_reports(results, output_dir, scan_dir):
    """Generate various report formats"""
    
    # JSON report
    json_report = {
        "scan_info": {
            "directory": scan_dir,
            "timestamp": datetime.now().isoformat(),
            "total_binaries": len(results)
        },
        "results": results
    }
    
    json_path = os.path.join(output_dir, "checksec_report.json")
    with open(json_path, 'w') as f:
        json.dump(json_report, f, indent=2)
    
    # HTML report
    html_path = os.path.join(output_dir, "checksec_report.html")
    generate_html_report(results, html_path, scan_dir)
    
    # Text summary
    txt_path = os.path.join(output_dir, "checksec_summary.txt")
    generate_text_summary(results, txt_path, scan_dir)
    
    print(f"\n✅ Reports generated:")
    print(f"   JSON: {json_path}")
    print(f"   HTML: {html_path}")
    print(f"   Summary: {txt_path}")

def generate_html_report(results, output_path, scan_dir):
    """Generate HTML report"""
    
    html = f"""<!DOCTYPE html>
<html>
<head>
    <title>Checksec Report - {scan_dir}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        table {{ border-collapse: collapse; width: 100%; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
        .yes {{ color: green; font-weight: bold; }}
        .no {{ color: red; }}
        .partial {{ color: orange; }}
        .error {{ color: red; font-style: italic; }}
    </style>
</head>
<body>
    <h1>Checksec Security Analysis Report</h1>
    <p><strong>Directory:</strong> {scan_dir}</p>
    <p><strong>Generated:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    <p><strong>Total Binaries:</strong> {len(results)}</p>
    
    <table>
        <tr>
            <th>Binary</th>
            <th>RELRO</th>
            <th>Canary</th>
            <th>NX</th>
            <th>PIE</th>
            <th>Symbols</th>
            <th>FORTIFY</th>
            <th>Size</th>
        </tr>
"""
    
    for result in results:
        binary = result["relative_path"]
        checksec = result["checksec"]
        file_info = result["file_info"]
        
        if "error" in checksec:
            html += f"""
        <tr>
            <td>{binary}</td>
            <td colspan="6" class="error">{checksec["error"]}</td>
            <td>{file_info.get("size", "unknown")}</td>
        </tr>"""
        else:
            def format_value(value):
                if value == "Yes" or value == "Full":
                    return f'<span class="yes">{value}</span>'
                elif value == "Partial":
                    return f'<span class="partial">{value}</span>'
                else:
                    return f'<span class="no">{value}</span>'
            
            html += f"""
        <tr>
            <td>{binary}</td>
            <td>{format_value(checksec.get("relro", "No"))}</td>
            <td>{format_value(checksec.get("canary", "No"))}</td>
            <td>{format_value(checksec.get("nx", "No"))}</td>
            <td>{format_value(checksec.get("pie", "No"))}</td>
            <td>{format_value(checksec.get("symbols", "No"))}</td>
            <td>{format_value(checksec.get("fortify_source", "No"))}</td>
            <td>{file_info.get("size", "unknown")}</td>
        </tr>"""
    
    html += """
    </table>
</body>
</html>"""
    
    with open(output_path, 'w') as f:
        f.write(html)

def generate_text_summary(results, output_path, scan_dir):
    """Generate text summary"""
    
    # Count security features
    stats = {
        "total": len(results),
        "relro_full": 0,
        "relro_partial": 0,
        "canary": 0,
        "nx": 0,
        "pie": 0,
        "fortify": 0,
        "errors": 0
    }
    
    vulnerable_binaries = []
    
    for result in results:
        checksec = result["checksec"]
        
        if "error" in checksec:
            stats["errors"] += 1
            continue
        
        if checksec.get("relro") == "Full":
            stats["relro_full"] += 1
        elif checksec.get("relro") == "Partial":
            stats["relro_partial"] += 1
        
        if checksec.get("canary") == "Yes":
            stats["canary"] += 1
        
        if checksec.get("nx") == "Yes":
            stats["nx"] += 1
        
        if checksec.get("pie") == "Yes":
            stats["pie"] += 1
        
        if checksec.get("fortify_source") == "Yes":
            stats["fortify"] += 1
        
        # Check if binary is vulnerable (missing multiple protections)
        protections = [
            checksec.get("relro") in ["Full", "Partial"],
            checksec.get("canary") == "Yes",
            checksec.get("nx") == "Yes",
            checksec.get("pie") == "Yes"
        ]
        
        if sum(protections) < 2:  # Less than 2 protections
            vulnerable_binaries.append(result["relative_path"])
    
    summary = f"""Checksec Security Analysis Summary
=====================================

Directory: {scan_dir}
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Statistics:
-----------
Total binaries analyzed: {stats["total"]}
Analysis errors: {stats["errors"]}

Security Features:
------------------
RELRO (Full):     {stats["relro_full"]:3d} / {stats["total"]} ({stats["relro_full"]/stats["total"]*100:.1f}%)
RELRO (Partial):  {stats["relro_partial"]:3d} / {stats["total"]} ({stats["relro_partial"]/stats["total"]*100:.1f}%)
Stack Canary:     {stats["canary"]:3d} / {stats["total"]} ({stats["canary"]/stats["total"]*100:.1f}%)
NX (DEP):         {stats["nx"]:3d} / {stats["total"]} ({stats["nx"]/stats["total"]*100:.1f}%)
PIE (ASLR):       {stats["pie"]:3d} / {stats["total"]} ({stats["pie"]/stats["total"]*100:.1f}%)
FORTIFY_SOURCE:   {stats["fortify"]:3d} / {stats["total"]} ({stats["fortify"]/stats["total"]*100:.1f}%)

Potentially Vulnerable Binaries:
---------------------------------
"""
    
    if vulnerable_binaries:
        for binary in vulnerable_binaries:
            summary += f"  - {binary}\n"
    else:
        summary += "  None found (all binaries have adequate protections)\n"
    
    summary += f"""
Recommendations:
----------------
1. Enable full RELRO for {stats["total"] - stats["relro_full"]} binaries
2. Add stack canaries to {stats["total"] - stats["canary"]} binaries  
3. Enable NX/DEP for {stats["total"] - stats["nx"]} binaries
4. Enable PIE/ASLR for {stats["total"] - stats["pie"]} binaries
5. Use FORTIFY_SOURCE for {stats["total"] - stats["fortify"]} binaries

Compile with: gcc -fstack-protector-all -D_FORTIFY_SOURCE=2 -Wl,-z,relro,-z,now -fPIE -pie
"""
    
    with open(output_path, 'w') as f:
        f.write(summary)

def main():
    parser = argparse.ArgumentParser(description='Batch checksec analysis')
    parser.add_argument('directory', help='Directory to scan for binaries')
    parser.add_argument('--output', default='./checksec_reports', help='Output directory for reports')
    
    args = parser.parse_args()
    
    if not os.path.exists(args.directory):
        print(f"❌ Error: Directory not found: {args.directory}")
        sys.exit(1)
    
    analyze_directory(args.directory, args.output)

if __name__ == "__main__":
    main()