#!/usr/bin/env python3
"""
Heap Analyzer
Analyzes heap layout and protections in a binary
"""

import sys
import os
import subprocess

def analyze_heap(binary_path):
    """Analyze heap layout and protections"""
    
    print(f"Analyzing heap protections in {binary_path}...")
    print("=" * 60)
    
    # Check if binary exists
    if not os.path.exists(binary_path):
        print(f"Error: Binary not found: {binary_path}")
        sys.exit(1)
    
    # Run file command
    print("\n[1] File information:")
    try:
        result = subprocess.run(['file', binary_path], capture_output=True, text=True)
        print(result.stdout)
    except Exception as e:
        print(f"Error running file command: {e}")
    
    # Check for heap-related symbols
    print("\n[2] Heap-related symbols:")
    try:
        result = subprocess.run(['nm', binary_path], capture_output=True, text=True)
        heap_symbols = [line for line in result.stdout.split('\n') 
                       if any(keyword in line.lower() for keyword in 
                             ['malloc', 'free', 'calloc', 'realloc', 'heap'])]
        if heap_symbols:
            for symbol in heap_symbols[:20]:
                print(f"  {symbol}")
        else:
            print("  No heap symbols found (might be stripped)")
    except Exception as e:
        print(f"Error checking symbols: {e}")
    
    # Check security features with checksec
    print("\n[3] Security features:")
    try:
        result = subprocess.run(['checksec', '--file=' + binary_path], 
                              capture_output=True, text=True)
        print(result.stdout)
    except FileNotFoundError:
        print("  checksec not found, install with: pf install-checksec")
    except Exception as e:
        print(f"Error running checksec: {e}")
    
    # Look for heap exploitation mitigations
    print("\n[4] Heap exploitation considerations:")
    print("  Modern heap implementations include:")
    print("    • Safe-Linking (GLIBC 2.32+): Protects fd/bk pointers")
    print("    • Tcache (GLIBC 2.26+): Fast bins for small allocations")
    print("    • Tcache key (GLIBC 2.29+): Double-free detection")
    print("    • Top chunk integrity checks")
    print("    • Unsorted bin integrity checks")
    
    # Check GLIBC version if possible
    try:
        result = subprocess.run(['ldd', '--version'], capture_output=True, text=True)
        version_line = result.stdout.split('\n')[0]
        print(f"\n  System GLIBC: {version_line}")
    except:
        pass
    
    print("\n[5] Common heap vulnerabilities to check for:")
    vulnerabilities = [
        "Use-after-free",
        "Double-free",
        "Heap overflow",
        "Off-by-one heap overflow",
        "Fastbin dup",
        "Unsorted bin attack",
        "Tcache poisoning",
        "House of Force",
        "House of Orange",
        "House of Einherjar",
    ]
    for vuln in vulnerabilities:
        print(f"  • {vuln}")
    
    print("\n" + "=" * 60)
    print("\nNext steps for heap exploitation:")
    print("  1. Build practice binaries: pf build-heap-exploits")
    print("  2. Study heap implementation: man malloc")
    print("  3. Use GDB with heap plugins: pf install-debuggers")
    print("  4. Practice with CTF challenges")
    
    print("\nUseful GDB commands for heap analysis:")
    gdb_commands = [
        "heap chunks - Show all heap chunks (pwndbg)",
        "heap bins - Show heap bins (pwndbg)",
        "vis_heap_chunks - Visualize heap (pwndbg)",
        "parseheap - Parse heap structure (gef)",
        "x/40gx <address> - Examine heap memory",
    ]
    for cmd in gdb_commands:
        print(f"  • {cmd}")

def main():
    if len(sys.argv) < 2:
        print("Usage: heap_analyzer.py <binary>")
        print("Example: heap_analyzer.py vuln_binary")
        sys.exit(1)
    
    binary_path = sys.argv[1]
    analyze_heap(binary_path)

if __name__ == '__main__':
    main()
