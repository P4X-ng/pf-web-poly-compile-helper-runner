#!/usr/bin/env python3
"""
pwntools Exploit Template Generator
Generates exploit templates using pwntools for various binary types
"""

import sys
import os
import argparse
from pathlib import Path

def generate_template(binary_path, output_path, arch=None, bits=None):
    """Generate a pwntools exploit template"""
    
    binary_name = Path(binary_path).name
    
    # Detect architecture if not specified
    if not arch:
        # Try to detect from file command
        try:
            import subprocess
            result = subprocess.run(['file', binary_path], capture_output=True, text=True)
            if 'x86-64' in result.stdout or 'x86_64' in result.stdout:
                arch = 'amd64'
                bits = 64
            elif 'i386' in result.stdout or '80386' in result.stdout:
                arch = 'i386'
                bits = 32
            elif 'ARM' in result.stdout:
                arch = 'arm'
                bits = 32
            else:
                arch = 'amd64'  # Default
                bits = 64
        except Exception:
            arch = 'amd64'
            bits = 64
    
    if not bits:
        bits = 64 if arch == 'amd64' else 32
    
    template = f'''#!/usr/bin/env python3
"""
Exploit template for {binary_name}
Generated by pf exploit development tools
"""

from pwn import *

# Set up pwntools for the correct architecture
context.arch = '{arch}'
context.bits = {bits}
context.endian = 'little'

# Binary path
binary_path = '{binary_path}'
binary = ELF(binary_path)

def exploit():
    """Main exploit function"""
    
    # Start the process (local)
    # p = process(binary_path)
    
    # Or connect to remote (uncomment and modify as needed)
    # p = remote('target.com', 1337)
    
    # For debugging (uncomment to attach gdb)
    # gdb.attach(p, gdbscript="""
    #     break main
    #     continue
    # """)
    
    # Example payload construction
    payload = b""
    payload += b"A" * 64  # Adjust offset as needed
    
    # Add ROP chain here if needed
    # rop = ROP(binary)
    # rop.call('system', ['/bin/sh'])
    # payload += rop.chain()
    
    # Send payload
    # p.sendline(payload)
    
    # Get shell (if exploit is successful)
    # p.interactive()
    
    print("Exploit template generated!")
    print("Modify the payload construction above for your specific target.")
    print("Use 'pf rop-find-gadgets binary={binary_path}' to find ROP gadgets.")
    print("Use 'pf pwn-cyclic length=200' to generate patterns for offset finding.")

def check_protections():
    """Check binary protections"""
    print("Binary protections:")
    print(f"  ASLR: {{binary.aslr}}")
    print(f"  Canary: {{binary.canary}}")
    print(f"  NX: {{binary.nx}}")
    print(f"  PIE: {{binary.pie}}")
    print(f"  RELRO: {{binary.relro}}")
    print(f"  FORTIFY: {{binary.fortify}}")

if __name__ == "__main__":
    print(f"Exploit template for {{binary_path}}")
    print(f"Architecture: {arch} ({bits}-bit)")
    print()
    
    check_protections()
    print()
    
    exploit()
'''

    # Write template to file
    with open(output_path, 'w') as f:
        f.write(template)
    
    # Make executable
    os.chmod(output_path, 0o755)
    
    print(f"✅ Exploit template generated: {output_path}")
    print(f"   Target binary: {binary_path}")
    print(f"   Architecture: {arch} ({bits}-bit)")
    print()
    print("Next steps:")
    print(f"   1. Edit {output_path} to customize the payload")
    print(f"   2. Use 'pf rop-find-gadgets binary={binary_path}' for ROP gadgets")
    print(f"   3. Use 'pf pwn-cyclic length=200' for offset finding")
    print(f"   4. Run the exploit: python3 {output_path}")

def main():
    parser = argparse.ArgumentParser(description='Generate pwntools exploit template')
    parser.add_argument('binary', help='Target binary path')
    parser.add_argument('output', help='Output exploit file path')
    parser.add_argument('--arch', help='Target architecture (amd64, i386, arm, etc.)')
    parser.add_argument('--bits', type=int, help='Architecture bits (32 or 64)')
    
    args = parser.parse_args()
    
    if not os.path.exists(args.binary):
        print(f"❌ Error: Binary file not found: {args.binary}")
        sys.exit(1)
    
    try:
        generate_template(args.binary, args.output, args.arch, args.bits)
    except Exception as e:
        print(f"❌ Error generating template: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()