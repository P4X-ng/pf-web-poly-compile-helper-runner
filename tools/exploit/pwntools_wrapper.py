#!/usr/bin/env python3
"""
pwntools Integration Wrapper
Provides pf task integration for pwntools exploit development framework
"""

import os
import sys
import json
import argparse
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Union

class PwntoolsWrapper:
    """Wrapper for pwntools functionality"""
    
    def __init__(self):
        self.check_pwntools()
    
    def check_pwntools(self):
        """Check if pwntools is installed"""
        try:
            import pwn
            self.pwntools_available = True
        except ImportError:
            self.pwntools_available = False
    
    def install_pwntools(self):
        """Install pwntools via pip"""
        print("Installing pwntools...")
        try:
            subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'pwntools'])
            print("‚úÖ pwntools installed successfully")
            return True
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Failed to install pwntools: {e}")
            return False
    
    def generate_template(self, output_file: str, binary_path: Optional[str] = None, 
                         remote_host: Optional[str] = None, remote_port: Optional[int] = None):
        """Generate exploit template"""
        if not self.pwntools_available:
            print("‚ùå pwntools not available. Install with: pf install-pwntools")
            return False
        
        template = self._create_exploit_template(binary_path, remote_host, remote_port)
        
        try:
            with open(output_file, 'w') as f:
                f.write(template)
            print(f"‚úÖ Exploit template created: {output_file}")
            return True
        except IOError as e:
            print(f"‚ùå Failed to write template: {e}")
            return False
    
    def _create_exploit_template(self, binary_path: Optional[str] = None, 
                                remote_host: Optional[str] = None, 
                                remote_port: Optional[int] = None) -> str:
        """Create exploit template content"""
        template = '''#!/usr/bin/env python3
"""
Exploit Template Generated by pf pwn-template
"""

from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64', os='linux')

# Binary and process setup
'''
        
        if binary_path:
            template += f'''binary_path = "{binary_path}"
exe = ELF(binary_path)
context.binary = exe

'''
        
        if remote_host and remote_port:
            template += f'''# Remote connection
def get_connection():
    if args.REMOTE:
        return remote("{remote_host}", {remote_port})
    else:
        return process(binary_path if binary_path else "./target")

'''
        else:
            template += '''# Process connection
def get_connection():
    if args.REMOTE:
        # Update with actual remote details
        return remote("localhost", 1337)
    else:
        return process(binary_path if 'binary_path' in locals() else "./target")

'''
        
        template += '''def main():
    # Get connection
    io = get_connection()
    
    # Example exploit code
    # TODO: Add your exploit logic here
    
    # Example: Send payload
    # payload = b"A" * 64  # Buffer overflow
    # payload += p64(0xdeadbeef)  # Return address
    # io.sendline(payload)
    
    # Example: Interact with shell
    # io.interactive()
    
    print("üéØ Exploit template ready - add your payload logic!")
    io.close()

if __name__ == "__main__":
    main()
'''
        
        return template
    
    def checksec_binary(self, binary_path: str, output_format: str = "table"):
        """Run checksec on binary using pwntools"""
        if not self.pwntools_available:
            print("‚ùå pwntools not available. Install with: pf install-pwntools")
            return False
        
        try:
            from pwn import ELF
            elf = ELF(binary_path)
            
            # Get security features
            security_info = {
                "file": binary_path,
                "arch": elf.arch,
                "bits": elf.bits,
                "endian": elf.endian,
                "nx": elf.nx,
                "pie": elf.pie,
                "canary": elf.canary,
                "relro": elf.relro,
                "rpath": bool(elf.get_section_by_name('.rpath')),
                "runpath": bool(elf.get_section_by_name('.runpath'))
            }
            
            if output_format == "json":
                print(json.dumps(security_info, indent=2))
            else:
                self._print_checksec_table(security_info)
            
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to analyze binary: {e}")
            return False
    
    def _print_checksec_table(self, info: Dict):
        """Print checksec information in table format"""
        filename = os.path.basename(info["file"])
        print(f"\nBinary Security Analysis (pwntools): {filename}")
        print("=" * (len(filename) + 35))
        print(f"Architecture:    {info['arch']}")
        print(f"Bits:            {info['bits']}")
        print(f"Endian:          {info['endian']}")
        print(f"NX:              {'Enabled' if info['nx'] else 'Disabled'}")
        print(f"PIE:             {'Enabled' if info['pie'] else 'Disabled'}")
        print(f"Canary:          {'Enabled' if info['canary'] else 'Disabled'}")
        print(f"RELRO:           {info['relro']}")
        print(f"RPATH:           {'Present' if info['rpath'] else 'Not present'}")
        print(f"RUNPATH:         {'Present' if info['runpath'] else 'Not present'}")
    
    def generate_cyclic(self, length: int = 200, output_file: Optional[str] = None):
        """Generate cyclic pattern for buffer overflow testing"""
        if not self.pwntools_available:
            print("‚ùå pwntools not available. Install with: pf install-pwntools")
            return False
        
        try:
            from pwn import cyclic
            pattern = cyclic(length)
            
            if output_file:
                with open(output_file, 'wb') as f:
                    f.write(pattern)
                print(f"‚úÖ Cyclic pattern ({length} bytes) saved to: {output_file}")
            else:
                print(f"Cyclic pattern ({length} bytes):")
                print(pattern.decode('latin-1'))
            
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to generate cyclic pattern: {e}")
            return False
    
    def find_cyclic_offset(self, value: Union[str, int]):
        """Find offset in cyclic pattern"""
        if not self.pwntools_available:
            print("‚ùå pwntools not available. Install with: pf install-pwntools")
            return False
        
        try:
            from pwn import cyclic_find, p64, p32
            
            # Handle different input formats
            if isinstance(value, str):
                if value.startswith('0x'):
                    # Hex string
                    int_value = int(value, 16)
                else:
                    # Try as string first, then as hex
                    try:
                        int_value = int(value)
                    except ValueError:
                        int_value = int(value, 16)
            else:
                int_value = value
            
            # Try both 32-bit and 64-bit
            try:
                # Try as 64-bit packed value
                packed_64 = p64(int_value)
                offset_64 = cyclic_find(packed_64)
                if offset_64 != -1:
                    print(f"‚úÖ Found offset (64-bit): {offset_64}")
                    return True
            except:
                pass
            
            try:
                # Try as 32-bit packed value
                packed_32 = p32(int_value & 0xffffffff)
                offset_32 = cyclic_find(packed_32)
                if offset_32 != -1:
                    print(f"‚úÖ Found offset (32-bit): {offset_32}")
                    return True
            except:
                pass
            
            # Try as raw bytes
            try:
                if isinstance(value, str) and not value.startswith('0x'):
                    offset = cyclic_find(value.encode())
                    if offset != -1:
                        print(f"‚úÖ Found offset (string): {offset}")
                        return True
            except:
                pass
            
            print(f"‚ùå Offset not found for value: {value}")
            return False
            
        except Exception as e:
            print(f"‚ùå Failed to find cyclic offset: {e}")
            return False
    
    def generate_shellcode(self, arch: str = "amd64", shell: bool = True, 
                          output_file: Optional[str] = None):
        """Generate shellcode"""
        if not self.pwntools_available:
            print("‚ùå pwntools not available. Install with: pf install-pwntools")
            return False
        
        try:
            from pwn import shellcraft, asm, context
            
            # Set architecture
            context.arch = arch
            
            if shell:
                # Generate shell shellcode
                if arch in ['amd64', 'x86_64']:
                    shellcode_src = shellcraft.amd64.sh()
                elif arch in ['i386', 'x86']:
                    shellcode_src = shellcraft.i386.sh()
                else:
                    print(f"‚ùå Unsupported architecture: {arch}")
                    return False
            else:
                # Generate exit shellcode
                if arch in ['amd64', 'x86_64']:
                    shellcode_src = shellcraft.amd64.exit(0)
                elif arch in ['i386', 'x86']:
                    shellcode_src = shellcraft.i386.exit(0)
                else:
                    print(f"‚ùå Unsupported architecture: {arch}")
                    return False
            
            # Assemble shellcode
            shellcode = asm(shellcode_src)
            
            if output_file:
                with open(output_file, 'wb') as f:
                    f.write(shellcode)
                print(f"‚úÖ Shellcode ({len(shellcode)} bytes) saved to: {output_file}")
            else:
                print(f"Shellcode ({arch}, {len(shellcode)} bytes):")
                print(f"Hex: {shellcode.hex()}")
                print(f"Python: {repr(shellcode)}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to generate shellcode: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="pwntools integration wrapper",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --install                           # Install pwntools
  %(prog)s --template exploit.py               # Generate exploit template
  %(prog)s --template exploit.py --binary ./target
  %(prog)s --checksec ./binary                 # Check binary security
  %(prog)s --cyclic 200                        # Generate cyclic pattern
  %(prog)s --cyclic 200 --output pattern.txt   # Save to file
  %(prog)s --find-offset 0x61616161            # Find offset in pattern
  %(prog)s --shellcode --arch amd64            # Generate shellcode
        """
    )
    
    parser.add_argument("--install", action="store_true", help="Install pwntools")
    parser.add_argument("--template", metavar="FILE", help="Generate exploit template")
    parser.add_argument("--binary", metavar="PATH", help="Binary path for template")
    parser.add_argument("--remote-host", metavar="HOST", help="Remote host for template")
    parser.add_argument("--remote-port", metavar="PORT", type=int, help="Remote port for template")
    parser.add_argument("--checksec", metavar="BINARY", help="Check binary security features")
    parser.add_argument("--json", action="store_true", help="Output in JSON format")
    parser.add_argument("--cyclic", metavar="LENGTH", type=int, help="Generate cyclic pattern")
    parser.add_argument("--output", metavar="FILE", help="Output file")
    parser.add_argument("--find-offset", metavar="VALUE", help="Find offset in cyclic pattern")
    parser.add_argument("--shellcode", action="store_true", help="Generate shellcode")
    parser.add_argument("--arch", metavar="ARCH", default="amd64", help="Architecture (amd64, i386)")
    parser.add_argument("--no-shell", action="store_true", help="Generate exit shellcode instead of shell")
    
    args = parser.parse_args()
    
    wrapper = PwntoolsWrapper()
    
    if args.install:
        wrapper.install_pwntools()
    elif args.template:
        wrapper.generate_template(args.template, args.binary, args.remote_host, args.remote_port)
    elif args.checksec:
        output_format = "json" if args.json else "table"
        wrapper.checksec_binary(args.checksec, output_format)
    elif args.cyclic:
        wrapper.generate_cyclic(args.cyclic, args.output)
    elif args.find_offset:
        wrapper.find_cyclic_offset(args.find_offset)
    elif args.shellcode:
        wrapper.generate_shellcode(args.arch, not args.no_shell, args.output)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()