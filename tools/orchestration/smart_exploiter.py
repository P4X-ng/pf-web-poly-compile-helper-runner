#!/usr/bin/env python3
"""
Smart Exploiter - Intelligent exploit development workflow
Combines checksec, ROP analysis, shellcode generation, and exploit templates
Part of the pf smart workflows system
"""

import os
import sys
import json
import argparse
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Optional

class SmartExploiter:
    """Intelligent exploit development that combines multiple tools"""
    
    def __init__(self):
        self.results = {}
        self.target_info = {}
        self.exploit_techniques = []
        
    def analyze_target(self, binary_path: str) -> Dict[str, any]:
        """Analyze target binary for exploitation potential"""
        print(f"ðŸŽ¯ Analyzing target: {binary_path}")
        
        # Use unified checksec for security analysis
        try:
            result = subprocess.run(['python3', 'tools/unified/unified_checksec.py', 
                                   '--format', 'json', binary_path], 
                                  capture_output=True, text=True, check=True)
            security_features = json.loads(result.stdout)
        except (subprocess.CalledProcessError, json.JSONDecodeError):
            # Fallback to basic analysis
            security_features = self._basic_security_analysis(binary_path)
        
        # Determine exploitation techniques based on security features
        techniques = self._determine_techniques(security_features)
        
        self.target_info = {
            'binary_path': binary_path,
            'security_features': security_features,
            'recommended_techniques': techniques
        }
        
        return self.target_info
    
    def _basic_security_analysis(self, binary_path: str) -> Dict[str, any]:
        """Basic security analysis fallback"""
        analysis = {
            'canary': False,
            'nx': False,
            'pie': False,
            'relro': 'No',
            'stripped': True
        }
        
        try:
            # Check for stack canary
            result = subprocess.run(['strings', binary_path], capture_output=True, text=True)
            if '__stack_chk_fail' in result.stdout:
                analysis['canary'] = True
            
            # Basic file analysis
            result = subprocess.run(['file', binary_path], capture_output=True, text=True)
            if 'not stripped' in result.stdout:
                analysis['stripped'] = False
        except subprocess.CalledProcessError:
            pass
        
        return analysis
    
    def _determine_techniques(self, security_features: Dict[str, any]) -> List[str]:
        """Determine appropriate exploitation techniques"""
        techniques = []
        
        # Check for buffer overflow potential
        if not security_features.get('canary', True):
            techniques.append('buffer_overflow')
            
        # Check for ROP potential
        if security_features.get('nx', False):
            techniques.append('rop_chain')
        else:
            techniques.append('shellcode_injection')
            
        # Check for format string potential
        techniques.append('format_string')  # Always check
        
        # Check for GOT overwrite potential
        if security_features.get('relro', 'Full') != 'Full':
            techniques.append('got_overwrite')
        
        return techniques
    
    def generate_exploit_template(self, binary_path: str, output_file: str, 
                                arch: str = 'amd64') -> Dict[str, any]:
        """Generate exploit template using pwntools"""
        print(f"ðŸ“ Generating exploit template for {arch}...")
        
        try:
            # Use pwntools wrapper if available
            result = subprocess.run(['python3', 'tools/exploit/pwntools_wrapper.py', 
                                   '--template', output_file, '--binary', binary_path], 
                                  capture_output=True, text=True, check=True)
            
            return {
                'template_generated': True,
                'output_file': output_file,
                'method': 'pwntools_wrapper'
            }
        except subprocess.CalledProcessError:
            # Fallback to basic template
            return self._generate_basic_template(binary_path, output_file, arch)
    
    def _generate_basic_template(self, binary_path: str, output_file: str, 
                               arch: str) -> Dict[str, any]:
        """Generate basic exploit template"""
        template = f'''#!/usr/bin/env python3
"""
Exploit for {binary_path}
Generated by pf smart-exploit
"""

import sys
import struct

# Target binary: {binary_path}
# Architecture: {arch}
# Security features: {self.target_info.get('security_features', {{}})}

def main():
    print("Exploit template for {binary_path}")
    
    # TODO: Implement exploitation logic based on:
    # Recommended techniques: {self.target_info.get('recommended_techniques', [])}
    
    # Example buffer overflow payload
    payload = b"A" * 100  # Adjust offset as needed
    
    print(f"Payload length: {{len(payload)}}")
    print(f"Payload: {{payload}}")
    
    # TODO: Send payload to target
    # with open('{binary_path}', 'wb') as f:
    #     f.write(payload)

if __name__ == '__main__':
    main()
'''
        
        with open(output_file, 'w') as f:
            f.write(template)
        
        os.chmod(output_file, 0o755)
        
        return {
            'template_generated': True,
            'output_file': output_file,
            'method': 'basic_template'
        }
    
    def find_rop_gadgets(self, binary_path: str) -> Dict[str, any]:
        """Find ROP gadgets using available tools"""
        print(f"ðŸ” Finding ROP gadgets...")
        
        try:
            # Try ROPgadget first
            result = subprocess.run(['python3', 'tools/exploit/ropgadget_wrapper.py', 
                                   '--find-gadgets', binary_path], 
                                  capture_output=True, text=True, check=True)
            
            return {
                'gadgets_found': True,
                'method': 'ropgadget_wrapper',
                'output': result.stdout
            }
        except subprocess.CalledProcessError:
            # Fallback to basic gadget search
            return self._basic_gadget_search(binary_path)
    
    def _basic_gadget_search(self, binary_path: str) -> Dict[str, any]:
        """Basic ROP gadget search using objdump"""
        try:
            result = subprocess.run(['objdump', '-d', binary_path], 
                                  capture_output=True, text=True, check=True)
            
            # Look for common gadgets
            gadgets = []
            lines = result.stdout.split('\n')
            for line in lines:
                if 'ret' in line:
                    gadgets.append(line.strip())
            
            return {
                'gadgets_found': len(gadgets) > 0,
                'method': 'basic_objdump',
                'gadget_count': len(gadgets),
                'sample_gadgets': gadgets[:10]
            }
        except subprocess.CalledProcessError:
            return {'gadgets_found': False, 'error': 'Could not analyze gadgets'}
    
    def generate_shellcode(self, arch: str = 'amd64') -> Dict[str, any]:
        """Generate shellcode for the target architecture"""
        print(f"ðŸ’¥ Generating shellcode for {arch}...")
        
        try:
            # Use pwntools wrapper
            result = subprocess.run(['python3', 'tools/exploit/pwntools_wrapper.py', 
                                   '--shellcode', '--arch', arch], 
                                  capture_output=True, text=True, check=True)
            
            return {
                'shellcode_generated': True,
                'method': 'pwntools_wrapper',
                'output': result.stdout
            }
        except subprocess.CalledProcessError:
            # Fallback shellcode
            return self._basic_shellcode(arch)
    
    def _basic_shellcode(self, arch: str) -> Dict[str, any]:
        """Basic shellcode examples"""
        shellcodes = {
            'amd64': {
                'execve_bin_sh': '\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05',
                'exit': '\\x48\\x31\\xff\\x6a\\x3c\\x58\\x0f\\x05'
            },
            'i386': {
                'execve_bin_sh': '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80',
                'exit': '\\x31\\xc0\\xb0\\x01\\xcd\\x80'
            }
        }
        
        return {
            'shellcode_generated': True,
            'method': 'basic_shellcode',
            'shellcodes': shellcodes.get(arch, shellcodes['amd64'])
        }
    
    def run_complete_workflow(self, binary_path: str, output_file: str = None, 
                            arch: str = 'amd64', technique: str = None) -> Dict[str, any]:
        """Run complete exploit development workflow"""
        if not output_file:
            output_file = f"{Path(binary_path).stem}_exploit.py"
        
        print("ðŸš€ Starting smart exploit development workflow...")
        
        workflow_results = {
            'target': binary_path,
            'output_file': output_file,
            'architecture': arch,
            'workflow_steps': []
        }
        
        # Step 1: Analyze target
        print("\n[1/4] Target Analysis")
        analysis_result = self.analyze_target(binary_path)
        workflow_results['analysis'] = analysis_result
        workflow_results['workflow_steps'].append('target_analysis')
        
        # Step 2: Generate exploit template
        print("\n[2/4] Exploit Template Generation")
        template_result = self.generate_exploit_template(binary_path, output_file, arch)
        workflow_results['template'] = template_result
        workflow_results['workflow_steps'].append('template_generation')
        
        # Step 3: ROP gadget analysis (if applicable)
        if 'rop_chain' in analysis_result.get('recommended_techniques', []):
            print("\n[3/4] ROP Gadget Analysis")
            rop_result = self.find_rop_gadgets(binary_path)
            workflow_results['rop_gadgets'] = rop_result
            workflow_results['workflow_steps'].append('rop_analysis')
        else:
            print("\n[3/4] ROP Analysis (Skipped - not applicable)")
        
        # Step 4: Shellcode generation
        print("\n[4/4] Shellcode Generation")
        shellcode_result = self.generate_shellcode(arch)
        workflow_results['shellcode'] = shellcode_result
        workflow_results['workflow_steps'].append('shellcode_generation')
        
        print(f"\nâœ… Smart exploit development complete!")
        print(f"ðŸ“„ Exploit template: {output_file}")
        
        return workflow_results


def main():
    parser = argparse.ArgumentParser(description='Smart Exploiter - Intelligent exploit development')
    parser.add_argument('binary', help='Target binary to exploit')
    parser.add_argument('--output', '-o', help='Output exploit file')
    parser.add_argument('--arch', default='amd64', choices=['amd64', 'i386', 'arm'], 
                       help='Target architecture')
    parser.add_argument('--technique', help='Specific exploitation technique to focus on')
    parser.add_argument('--format', choices=['json', 'text'], default='text', 
                       help='Output format')
    
    args = parser.parse_args()
    
    if not os.path.exists(args.binary):
        print(f"Error: Binary {args.binary} does not exist", file=sys.stderr)
        sys.exit(1)
    
    exploiter = SmartExploiter()
    results = exploiter.run_complete_workflow(args.binary, args.output, 
                                            args.arch, args.technique)
    
    if args.format == 'json':
        print(json.dumps(results, indent=2))
    else:
        print(f"\nðŸ“Š Exploit Development Summary:")
        print(f"Target: {results['target']}")
        print(f"Output: {results['output_file']}")
        print(f"Architecture: {results['architecture']}")
        print(f"Steps completed: {', '.join(results['workflow_steps'])}")
        
        if 'analysis' in results:
            techniques = results['analysis'].get('recommended_techniques', [])
            print(f"Recommended techniques: {', '.join(techniques)}")


if __name__ == '__main__':
    main()